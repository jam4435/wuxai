```
<!doctype html>
<html lang="zh">
  <head>
    <meta charset="UTF-8" />
    <title>è§’è‰²çŠ¶æ€</title>
    <style>
      :root {
        --bg-color: transparent;
        --container-bg: #1e1e1e;
        --text-color: #e0e0e0;
        --text-secondary-color: #b0b0b0;
        --accent-color: #6200ea;
        --accent-light-color: #bb86fc;
        --border-color: #333333;
        --red-color: #cf6679;
        --green-color: #03dac6;
      }
      body {
        font-family: 'Noto Sans SC', sans-serif;
        background-color: var(--bg-color);
      }
      .status-container {
        background-color: var(--container-bg);
        color: var(--text-color);
        border-radius: 12px;
        border: 1px solid var(--border-color);
        box-shadow: none;
        max-width: 600px;
        margin: auto;
        padding: 24px;
        box-sizing: border-box;
      }
      .header {
        display: flex;
        align-items: center;
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 1px solid var(--border-color);
      }
      .portrait {
        flex-shrink: 0;
        margin-right: 20px;
        position: relative; /* For upload button positioning */
      }
      .portrait img {
        width: 80px;
        height: 80px;
        border-radius: 50%;
        object-fit: cover;
        border: 2px solid var(--border-color);
        cursor: pointer;
        transition: transform 0.3s;
      }
      .portrait img:hover {
        transform: scale(1.1);
      }
      .portrait .portrait-upload-trigger {
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      .portrait:hover .portrait-upload-trigger {
        opacity: 1;
      }
      .portrait-upload-trigger {
        position: absolute;
        bottom: 2px;
        right: 2px;
        z-index: 2;
        z-index: 2;
        width: 28px;
        height: 28px;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        border: 1px solid var(--border-color);
        transition:
          background-color 0.3s,
          opacity 0.3s ease;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
      }
      .portrait-upload-trigger:hover {
        background-color: rgba(0, 0, 0, 0.9);
      }
      .portrait-upload-trigger svg {
        width: 16px;
        height: 16px;
      }
      .portrait-reset-trigger {
        position: absolute;
        bottom: 2px;
        right: 32px; /* Positioned next to the upload trigger */
        width: 28px;
        height: 28px;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        border: 1px solid var(--border-color);
        transition:
          background-color 0.3s,
          opacity 0.3s ease;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        z-index: 2;
        display: none; /* Hidden by default */
        opacity: 0;
      }
      .portrait:hover .portrait-reset-trigger {
        opacity: 1;
      }
      .portrait-reset-trigger:hover {
        background-color: rgba(0, 0, 0, 0.9);
      }
      .portrait-reset-trigger svg {
        width: 16px;
        height: 16px;
      }
      .header-info {
        flex-grow: 1;
      }
      .char-name {
        font-size: 24px;
        font-weight: 700;
        color: var(--accent-light-color);
        letter-spacing: 1px;
      }
      .meta-info {
        display: flex;
        justify-content: space-between;
        font-size: 13px;
        color: var(--text-secondary-color);
        margin-top: 8px;
      }
      .core-stats {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-bottom: 25px;
      }
      .stat-box {
        background-color: rgba(0, 0, 0, 0.2);
        padding: 15px;
        border-radius: 8px;
        text-align: center;
      }
      .stat-label {
        font-size: 14px;
        font-weight: 500;
        color: var(--text-secondary-color);
        margin-bottom: 8px;
      }
      .stat-value {
        font-size: 22px;
        font-weight: 700;
        color: var(--text-color);
      }
      .stat-value .arrow {
        font-size: 18px;
        margin: 0 5px;
      }
      .stat-change-reason {
        font-size: 12px;
        color: var(--text-secondary-color);
        margin-top: 5px;
        font-style: italic;
      }
      .green {
        color: var(--green-color);
      }
      .red {
        color: var(--red-color);
      }
      .narrative-block,
      .details-block {
        background-color: rgba(0, 0, 0, 0.2);
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 25px;
      }
      .narrative-label,
      .details-header {
        font-weight: 700;
        color: var(--accent-light-color);
        margin-bottom: 8px;
        display: block;
        font-size: 16px;
      }
      .narrative-content {
        font-size: 14px;
        line-height: 1.6;
        color: var(--text-color);
        white-space: pre-wrap;
        word-wrap: break-word;
      }
      .tabs {
        display: flex;
        justify-content: space-around;
        border-bottom: 2px solid var(--border-color);
        margin-bottom: 20px;
      }
      .tab-button {
        flex: 1;
        text-align: center;
        padding: 10px 20px;
        cursor: pointer;
        background: none;
        border: none;
        color: var(--text-secondary-color);
        font-size: 15px;
        font-weight: 500;
        transition:
          color 0.3s,
          border-bottom 0.3s;
        border-bottom: 3px solid transparent;
        margin-bottom: -2px;
      }
      .tab-button.active {
        color: var(--accent-light-color);
        border-bottom-color: var(--accent-light-color);
      }
      .tab-content {
        display: none;
      }
      .tab-content.active {
        display: block;
      }
      .details-list {
        list-style: none;
        padding: 0;
        margin: 0;
      }
      .details-item {
        display: flex;
        padding: 12px 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }
      .details-item:last-child {
        border-bottom: none;
      }
      .details-label {
        flex-basis: 120px;
        flex-shrink: 0;
        font-weight: 500;
        color: var(--text-secondary-color);
        padding-right: 15px;
      }
      .details-value {
        flex-grow: 1;
        color: var(--text-color);
      }
      .modifications-list {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        padding: 0;
        margin: 0;
        list-style: none;
      }
      .modifications-item {
        background-color: rgba(255, 255, 255, 0.1);
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 14px;
        border: none;
      }
      .image-link {
        color: var(--accent-light-color);
        text-decoration: underline;
        cursor: pointer;
      }
      .image-link:hover {
        color: var(--accent-color);
      }
      .gallery-modal {
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        display: none;
        justify-content: center;
        align-items: center;
      }
      .gallery-content {
        position: relative;
        max-width: 90vw;
        max-height: 90vh;
      }
      .gallery-image {
        max-width: 100%;
        max-height: 100%;
        display: block;
        margin: auto;
        cursor: grab;
        transition: transform 0.2s ease-out;
      }
      .gallery-image.dragging {
        cursor: grabbing;
      }
      .gallery-close {
        position: absolute;
        top: 15px;
        right: 35px;
        color: #f1f1f1;
        font-size: 40px;
        font-weight: bold;
        cursor: pointer;
        z-index: 10;
      }
      .gallery-prev,
      .gallery-next {
        cursor: pointer;
        position: absolute;
        top: 50%;
        width: auto;
        padding: 16px;
        margin-top: -22px;
        color: white;
        font-weight: bold;
        font-size: 20px;
        transition: 0.6s ease;
        border-radius: 0 3px 3px 0;
        user-select: none;
      }
      .gallery-next {
        right: 0;
        border-radius: 3px 0 0 3px;
      }
      .gallery-prev:hover,
      .gallery-next:hover {
        background-color: rgba(0, 0, 0, 0.8);
      }

      /* --- å“åº”å¼è®¾è®¡ï¼šé’ˆå¯¹å°å±å¹•è®¾å¤‡ --- */
      @media screen and (max-width: 480px) {
        .status-container {
          padding: 16px;
          margin: 10px;
          max-width: 100%;
        }

        .header {
          flex-direction: column;
          align-items: center;
          text-align: center;
        }

        .portrait {
          margin-right: 0;
          margin-bottom: 15px;
        }

        .header-info {
          width: 100%;
        }

        .meta-info {
          flex-direction: column;
          align-items: center;
          gap: 5px;
        }

        .core-stats {
          grid-template-columns: 1fr;
          gap: 15px;
        }

        .tab-button {
          font-size: 14px;
          padding: 8px 10px;
          white-space: normal;
          line-height: 1.3;
          flex-basis: 0; /* è®© flex-grow ç”Ÿæ•ˆ */
        }

        .details-item {
          flex-direction: column;
          align-items: flex-start;
          gap: 4px;
        }

        .details-label {
          flex-basis: auto;
        }
      }

      /* --- æŠ˜å åŠŸèƒ½æ ·å¼ --- */
      .collapsible-section {
        overflow: hidden;
        transition: max-height 0.4s ease-in-out, opacity 0.4s ease-in-out;
        max-height: 2000px; /* è®¾ç½®ä¸€ä¸ªè¶³å¤Ÿå¤§çš„å€¼ä»¥å®¹çº³æ‰€æœ‰å†…å®¹ */
        opacity: 1;
      }

      .status-container.collapsed .collapsible-section {
        max-height: 0;
        opacity: 0;
      }

      .collapse-toggle {
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 32px;
        height: 32px;
        border-radius: 50%;
        background-color: rgba(255, 255, 255, 0.1);
        transition: background-color 0.3s, transform 0.3s;
        flex-shrink: 0;
        margin-left: 15px;
      }

      .collapse-toggle:hover {
        background-color: rgba(255, 255, 255, 0.2);
      }

      .collapse-toggle svg {
        width: 20px;
        height: 20px;
        fill: var(--text-secondary-color);
        transition: transform 0.3s, fill 0.3s;
      }

      .status-container.collapsed .collapse-toggle svg {
        transform: rotate(180deg);
      }

      .collapse-toggle:hover svg {
        fill: var(--text-color);
      }
    </style>
  </head>
  <body>
    <div id="jm-state-panel-1" class="status-container">
      <!-- Content will be generated by script -->
    </div>

    <script>
      // --- å…¨å±€æ•°æ®ç®¡ç†å™¨ï¼Œç¡®ä¿æ•°æ®åªåŠ è½½ä¸€æ¬¡ ---
      window.JM_StatusDataManager =
        window.JM_StatusDataManager ||
        (function () {
          let dataPromise = null;

          async function fetchDataInternal() {
            const GITHUB_BASE_URL = 'https://raw.githubusercontent.com/jam4435/my-image-hosting/main/jm/';
            const IMAGE_INDEX_URL =
              'https://raw.githubusercontent.com/jam4435/my-image-hosting/main/jm/imageIndex.json';
            const SYNONYMS_URL = 'https://raw.githubusercontent.com/jam4435/my-image-hosting/main/jm/synonyms.json';
            const FACE_INDEX_URL = GITHUB_BASE_URL.replace('/jm/', '/face/') + 'face_index.json';

            console.log('[çŠ¶æ€æ  å…¨å±€] å¼€å§‹åŠ è½½æ ¸å¿ƒæ•°æ®...');

            try {
              const [imageResponse, synonymResponse, faceResponse] = await Promise.all([
                fetch(IMAGE_INDEX_URL),
                fetch(SYNONYMS_URL),
                fetch(FACE_INDEX_URL),
              ]);

              const data = {
                imageIndex: {},
                synonymMap: {},
                fallbackAvatars: [],
                allKeywords: [],
                keywordRegex: null,
              };

              if (!imageResponse.ok) throw new Error(`å›¾ç‰‡ç´¢å¼•åŠ è½½å¤±è´¥: ${imageResponse.status}`);
              data.imageIndex = await imageResponse.json();

              if (synonymResponse.ok) {
                const synonymData = await synonymResponse.json();
                for (const mainKeyword in synonymData) {
                  synonymData[mainKeyword].forEach(alias => {
                    data.synonymMap[alias] = mainKeyword;
                  });
                }
              } else {
                console.warn(`[çŠ¶æ€æ  å…¨å±€] è­¦å‘Š: åŒä¹‰è¯æ–‡ä»¶ (synonyms.json) åŠ è½½å¤±è´¥: ${synonymResponse.status}.`);
              }

              if (faceResponse.ok) {
                data.fallbackAvatars = await faceResponse.json();
                console.log(`[çŠ¶æ€æ  å…¨å±€] å¤‡ç”¨å¤´åƒåˆ—è¡¨åŠ è½½æˆåŠŸï¼Œå…±è®¡ ${data.fallbackAvatars.length} ä¸ªå¤´åƒã€‚`);
              } else {
                console.warn(`[çŠ¶æ€æ  å…¨å±€] è­¦å‘Š: å¤‡ç”¨å¤´åƒç´¢å¼• (face_index.json) åŠ è½½å¤±è´¥: ${faceResponse.status}.`);
              }

              data.allKeywords = [...Object.keys(data.imageIndex), ...Object.keys(data.synonymMap)];

              if (data.allKeywords.length > 0) {
                const escapeRegExp = string => string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                data.allKeywords.sort((a, b) => b.length - a.length);
                data.keywordRegex = new RegExp(`(${data.allKeywords.map(escapeRegExp).join('|')})`, 'g');
              }

              console.log('[çŠ¶æ€æ  å…¨å±€] æ ¸å¿ƒæ•°æ®åŠ è½½å¹¶å¤„ç†å®Œæˆã€‚');
              return data;
            } catch (error) {
              console.error('[çŠ¶æ€æ  å…¨å±€] æ ¸å¿ƒæ•°æ®åŠ è½½å¤±è´¥:', error);
              throw error;
            }
          }

          return {
            getData: function () {
              if (!dataPromise) {
                dataPromise = fetchDataInternal();
              }
              return dataPromise;
            },
          };
        })();

      // --- IndexedDB åŠ©æ‰‹ï¼Œç”¨äºå­˜å‚¨ç”¨æˆ·ä¸Šä¼ çš„å¤´åƒ ---
      const idbHelper = {
        db: null,
        openDB: function () {
          if (this.db) return Promise.resolve(this.db);
          return new Promise((resolve, reject) => {
            const request = indexedDB.open('JM_UserData', 1);
            request.onupgradeneeded = event => {
              const db = event.target.result;
              if (!db.objectStoreNames.contains('portraits')) {
                db.createObjectStore('portraits', { keyPath: 'id' });
              }
            };
            request.onsuccess = event => {
              this.db = event.target.result;
              resolve(this.db);
            };
            request.onerror = event => {
              console.error('IndexedDB error:', event.target.errorCode);
              reject('IndexedDB error: ' + event.target.errorCode);
            };
          });
        },
        set: async function (id, value) {
          const db = await this.openDB();
          return new Promise((resolve, reject) => {
            const transaction = db.transaction(['portraits'], 'readwrite');
            const store = transaction.objectStore('portraits');
            const request = store.put({ id, value });
            request.onsuccess = () => resolve();
            request.onerror = event => reject('Error saving to IndexedDB: ' + event.target.error);
          });
        },
        get: async function (id) {
          const db = await this.openDB();
          return new Promise((resolve, reject) => {
            const transaction = db.transaction(['portraits'], 'readonly');
            const store = transaction.objectStore('portraits');
            const request = store.get(id);
            request.onsuccess = () => resolve(request.result ? request.result.value : undefined);
            request.onerror = event => reject('Error getting from IndexedDB: ' + event.target.error);
          });
        },
        delete: async function (id) {
          const db = await this.openDB();
          return new Promise((resolve, reject) => {
            const transaction = db.transaction(['portraits'], 'readwrite');
            const store = transaction.objectStore('portraits');
            const request = store.delete(id);
            request.onsuccess = () => resolve();
            request.onerror = event => reject('Error deleting from IndexedDB: ' + event.target.error);
          });
        },
      };

      document.addEventListener('DOMContentLoaded', () => {
        const panel = document.getElementById('jm-state-panel-1');

        function displayError(message, details = '') {
          const panelId = panel ? panel.id : 'æœªçŸ¥';
          console.error(`[çŠ¶æ€æ  ${panelId}] ` + message, details);
          panel.innerHTML = `<div style="color: var(--red-color); padding: 20px; font-family: monospace; white-space: pre-wrap;"><h3>çŠ¶æ€æ é”™è¯¯</h3><p>${message}</p><details><summary>è¯¦ç»†ä¿¡æ¯</summary><p>${details}</p></details></div>`;
        }

        try {
          const GITHUB_BASE_URL = 'https://raw.githubusercontent.com/jam4435/my-image-hosting/main/jm/';
          const rawData = `$2`;
          const jsonData = JSON.parse(rawData.trim());

          function safeGet(obj, path, defaultValue = undefined) {
            const keys = Array.isArray(path) ? path : path.split('.');
            let result = obj;
            for (const key of keys) {
              result = result?.[key];
              if (result === undefined) return defaultValue;
            }
            return result;
          }

          function uniq(arr) {
            return Array.from(new Set(arr));
          }

          // --- æ•°æ®ç°åœ¨ç”±å…¨å±€ç®¡ç†å™¨æä¾› ---
          let imageIndex, synonymMap, allKeywords, keywordRegex, fallbackAvatars;

          // --- æ¯ä¸ªé¢æ¿å®ä¾‹ç‹¬æœ‰çš„çŠ¶æ€ ---
          let currentGalleryImages = [];
          let currentGalleryIndex = 0;
          let currentGalleryBaseUrl = '';
          let portraitClickListener = null; // ç”¨äºç®¡ç†å¤´åƒç‚¹å‡»äº‹ä»¶

          function getDeterministicRandomIndex(seed, max) {
            if (!seed || max === 0) return 0;
            let hash = 0;
            for (let i = 0; i < seed.length; i++) {
              const char = seed.charCodeAt(i);
              hash = (hash << 5) - hash + char;
              hash |= 0; // Convert to 32bit integer
            }
            return Math.abs(hash) % max;
          }

          async function fetchData() {
            try {
              const sharedData = await window.JM_StatusDataManager.getData();
              // å°†å…±äº«æ•°æ®èµ‹å€¼ç»™é¢æ¿å®ä¾‹çš„å˜é‡
              imageIndex = sharedData.imageIndex;
              synonymMap = sharedData.synonymMap;
              fallbackAvatars = sharedData.fallbackAvatars;
              allKeywords = sharedData.allKeywords;
              keywordRegex = sharedData.keywordRegex;

              console.log(`[çŠ¶æ€æ  ${panel.id}] å·²ä»å…¨å±€ç®¡ç†å™¨è·å–æ•°æ®ã€‚`);
              return true;
            } catch (error) {
              const panelId = panel ? panel.id : 'æœªçŸ¥';
              console.error(`[çŠ¶æ€æ  ${panelId}] ä»å…¨å±€ç®¡ç†å™¨è·å–æ•°æ®å¤±è´¥:`, error);
              displayError('æ ¸å¿ƒæ•°æ®åŠ è½½å¤±è´¥', `é”™è¯¯: ${error.message}`);
              return false;
            }
          }

          function findImagesByKeyword(textToSearch) {
            if (!textToSearch || typeof textToSearch !== 'string') {
              return [];
            }
            let preliminaryMatches = [];
            for (const keyword of allKeywords) {
              if (textToSearch.includes(keyword)) {
                preliminaryMatches.push(keyword);
              }
            }
            const preciseMatches = preliminaryMatches.filter(shortMatch => {
              return !preliminaryMatches.some(
                longMatch => longMatch.length > shortMatch.length && longMatch.includes(shortMatch),
              );
            });
            const mainKeywordMatches = preciseMatches.map(match => {
              const mainKeyword = synonymMap[match] || match;
              return { keyword: mainKeyword, index: textToSearch.indexOf(match) };
            });
            mainKeywordMatches.sort((a, b) => a.index - b.index);

            let foundImages = [];
            for (const match of mainKeywordMatches) {
              const imageList = imageIndex[match.keyword];
              if (Array.isArray(imageList)) {
                const filteredList = imageList.filter(img => img !== 'éå¤´åƒ.abc');
                foundImages = foundImages.concat(filteredList);
              }
            }
            return uniq(foundImages);
          }

          function linkifyAllText() {
            if (!keywordRegex) return;

            panel.querySelectorAll('.details-value, .narrative-content').forEach(el => {
              // å¦‚æœå·²ç»æœ‰é“¾æ¥ï¼Œæˆ–è€…æ²¡æœ‰æ–‡æœ¬å†…å®¹ï¼Œåˆ™è·³è¿‡
              if (el.querySelector('a.image-link') || !el.textContent) return;

              const originalText = el.textContent;

              // ä½¿ç”¨é¢„ç¼–è¯‘çš„æ­£åˆ™è¡¨è¾¾å¼è¿›è¡Œæ›¿æ¢
              // é‡ç½®æ­£åˆ™è¡¨è¾¾å¼çš„ lastIndex ä»¥ç¡®ä¿ä»å¤´å¼€å§‹æœç´¢
              keywordRegex.lastIndex = 0;

              // ä»…å½“å®é™…å­˜åœ¨åŒ¹é…æ—¶æ‰è¿›è¡Œæ›¿æ¢æ“ä½œï¼Œé¿å…ä¸å¿…è¦çš„innerHTMLé‡å†™
              if (keywordRegex.test(originalText)) {
                keywordRegex.lastIndex = 0; // é‡ç½®ä»¥è¿›è¡Œæ›¿æ¢
                const newHtml = originalText.replace(keywordRegex, match => {
                  const mainKeyword = synonymMap[match] || match;
                  if (imageIndex[mainKeyword]) {
                    return `<a href="#" class="image-link" data-keyword="${match}">${match}</a>`;
                  }
                  return match; // å¦‚æœå…³é”®è¯åœ¨ imageIndex ä¸­æ²¡æœ‰å¯¹åº”é¡¹ï¼Œåˆ™ä¸åˆ›å»ºé“¾æ¥
                });
                el.innerHTML = newHtml;
              }
            });
          }

          function parseStat(statString) {
            if (typeof statString !== 'string') return null;
            const match = statString.match(/(\d+)\s*â†’\s*(\d+)\s*\((.*?)\)/);
            if (match) {
              return { from: match[1], to: match[2], reason: match[3] };
            }
            return null;
          }

          // --- æ–°å¢ï¼šåŠ¨æ€å†…å®¹é…ç½® ---
          const DYNAMIC_CONTENT_CONFIG = {
            // æ ¼å¼ a: æ•°å­—å˜åŒ– -> stat-box UI
            Affection: { label: 'å¥½æ„Ÿåº¦' },
            Libido: { label: 'æ€§æ¬²å€¼' },
            // æ ¼å¼ b: å­—ç¬¦ä¸² -> narrative-block UI
            Thoughts: { label: 'ğŸ§  å†…å¿ƒæƒ³æ³•' },
            RecentSex: { label: 'ğŸ“‹ æœ€è¿‘æ€§è¡Œä¸º' },
            // æ ¼å¼ c: åˆ—è¡¨ -> modifications-list UI
            ModificationsAndRestraints: { label: 'èº«ä½“æ”¹é€ ä¸æŸå…·' },
          };

          // --- æ–°å¢ï¼šUIæ¸²æŸ“å‡½æ•° ---

          // æ¸²æŸ“ "stat-box" (ç”¨äºå¥½æ„Ÿåº¦ç­‰)
          function renderStat(label, value) {
            const parsed = parseStat(value); // parseStat æ˜¯å·²æœ‰çš„å‡½æ•°
            let valueHtml = '';
            if (parsed) {
              valueHtml = `<div><span class="red">${parsed.from}</span> <span class="arrow">â†’</span> <span class="green">${parsed.to}</span></div><div class="stat-change-reason">(${parsed.reason})</div>`;
            } else {
              valueHtml = String(value);
            }
            return `
              <div class="stat-box">
                <div class="stat-label">${label}</div>
                <div class="stat-value">${valueHtml}</div>
              </div>
            `;
          }

          // æ¸²æŸ“ "narrative-block" (ç”¨äºå†…å¿ƒæƒ³æ³•ç­‰)
          function renderNarrative(label, value) {
            return `
              <div class="narrative-block">
                <span class="narrative-label">${label}</span>
                <p class="narrative-content">${String(value)}</p>
              </div>
            `;
          }

          // æ¸²æŸ“ "list" (ç”¨äºæ”¹é€ ä¸æŸå…·ç­‰)
          function renderList(label, items) {
            if (!Array.isArray(items) || items.length === 0) return '';
            const itemsHtml = items.map(item => `
              <li class="modifications-item">
                <span class="details-value" data-keyword="${item}">${item}</span>
              </li>
            `).join('');
            return `
              <div class="details-block">
                <div class="details-header">${label}</div>
                <ul class="modifications-list">${itemsHtml}</ul>
              </div>
            `;
          }

          const DYNAMIC_CONTENT_MAP = {
            Status: {
              title: 'èº«ä»½ä¸å½“å‰çŠ¶æ€',
              icon: 'ğŸ–ï¸',
              labels: {
                Identity: 'èº«ä»½',
                Occupation: 'èŒä¸š',
                Affiliation: 'ä»å±',
                Temperament: 'æ°”è´¨',
                Posture: 'å§¿åŠ¿',
              },
            },
            Outfit: {
              title: 'æœè£…ä¸å†…è¡£',
              icon: 'ğŸ‘—',
              labels: {
                Top: 'ä¸Šè£…',
                Bottom: 'ä¸‹è£…',
                Underwear: 'å†…è¡£',
                Footwear: 'é‹å±¥',
              },
            },
            BodyDetails: {
              title: 'èº«ä½“ä¸æ€§å™¨ç»†èŠ‚',
              icon: 'ğŸ©¸',
              labels: {
                Mouth: 'å£è…”',
                Breasts: 'èƒ¸éƒ¨',
                WombAndVagina: 'å­å®«ä¸é˜´é“',
                Anus: 'ååº­',
                Hands: 'æ‰‹éƒ¨',
                Legs: 'è…¿éƒ¨',
                Feet: 'è¶³éƒ¨',
              },
            },
          };

          function generateDynamicTabsAndContent(data) {
            const EXCLUDED_KEYS = new Set([
              'Name',
              'Location',
              'Time',
              'Affection',
              'Libido',
              'Thoughts',
              'RecentSex',
              'ModificationsAndRestraints',
              'Modifications',
            ]);

            let tabsHtml = '<div class="tabs">';
            let contentsHtml = '';
            let tabIndex = 0;

            for (const key in data) {
              if (
                !EXCLUDED_KEYS.has(key) &&
                typeof data[key] === 'object' &&
                data[key] !== null &&
                !Array.isArray(data[key])
              ) {
                const tabId = `dynamic-tab-${tabIndex}`;
                const isActive = tabIndex === 0 ? 'active' : '';
                const tabInfo = DYNAMIC_CONTENT_MAP[key] || { title: key, icon: 'ğŸ“‹', labels: {} };

                tabsHtml += `<button class="tab-button ${isActive}" data-tab="${tabId}">${tabInfo.icon} ${tabInfo.title}</button>`;

                contentsHtml += `<div id="${tabId}" class="tab-content ${isActive}"><ul class="details-list">`;

                for (const subKey in data[key]) {
                  const label = tabInfo.labels[subKey] || subKey;
                  const value = data[key][subKey];
                  contentsHtml += `
                    <li class="details-item">
                      <span class="details-label">${label}</span>
                      <span class="details-value">${value}</span>
                    </li>
                  `;
                }

                contentsHtml += '</ul></div>';
                tabIndex++;
              }
            }

            tabsHtml += '</div>';

            return { tabsHtml, contentsHtml };
          }

          function updatePanel(data) {
            // 1. è®¾ç½®åªåŒ…å«é™æ€éƒ¨åˆ†çš„HTMLæ¡†æ¶
            panel.innerHTML = `
                        <div class="header">
                            <div class="portrait">
                                <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="è§’è‰²è‚–åƒ" data-field="portrait" />
                                <div class="portrait-upload-trigger" title="ä¸Šä¼ æ–°å¤´åƒ"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34a.9959.9959 0 0 0-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg></div>
                                <div class="portrait-reset-trigger" title="é‡ç½®ä¸ºé»˜è®¤å¤´åƒ"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg></div>
                                <input type="file" id="jm-portrait-upload" style="display:none" accept="image/*" />
                            </div>
                            <div class="header-info">
                                <div class="char-name" data-field="Name"></div>
                                <div class="meta-info">
                                    <span class="location">ğŸ“ <span data-field="Location"></span></span>
                                    <span class="timestamp">ğŸ•°ï¸ <span data-field="Time"></span></span>
                                </div>
                            </div>
                            <div class="collapse-toggle" title="å±•å¼€/æŠ˜å ">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/>
                                </svg>
                            </div>
                        </div>

                        <!-- å¯æŠ˜å å†…å®¹åŒºåŸŸ -->
                        <div class="collapsible-section">
                            <!-- æ–°çš„åŠ¨æ€å†…å®¹å®¹å™¨ -->
                            <div id="jm-dynamic-content-area"></div>

                            <!-- åŠ¨æ€Tabé¡µå®¹å™¨ -->
                            <div class="tabs-container"></div>
                            <div class="tab-content-container"></div>
                        </div>

                        <div id="jm-image-gallery-1" class="gallery-modal">
                            <div class="gallery-content">
                                <span class="gallery-close">&times;</span>
                                <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class="gallery-image" />
                                <a class="gallery-prev">&#10094;</a>
                                <a class="gallery-next">&#10095;</a>
                            </div>
                        </div>
                    `;

            // 2. å¡«å……é™æ€å¤´éƒ¨æ•°æ®
            const staticFields = {
              Name: data.Name,
              Location: data.Location,
              Time: data.Time,
            };

            for (const field in staticFields) {
              const el = panel.querySelector(`[data-field="${field}"]`);
              if (el && staticFields[field] !== undefined) {
                el.textContent = staticFields[field];
              }
            }

            // 3. æ¸²æŸ“æ‰€æœ‰åŠ¨æ€å†…å®¹
            renderDynamicContent(data);

            // 4. ç”Ÿæˆå¹¶æ’å…¥åŠ¨æ€çš„Tabså’Œå†…å®¹ (è¿™éƒ¨åˆ†é€»è¾‘ä¸å˜)
            const { tabsHtml, contentsHtml } = generateDynamicTabsAndContent(data);
            panel.querySelector('.tabs-container').innerHTML = tabsHtml;
            panel.querySelector('.tab-content-container').innerHTML = contentsHtml;
          }

          // --- ä¿®æ”¹ï¼šä¸»æ¸²æŸ“å¾ªç¯ (æ”¯æŒè‡ªåŠ¨æ ¼å¼æ£€æµ‹å’ŒåŸå§‹é¡ºåº) ---
          function renderDynamicContent(data) {
            const container = panel.querySelector('#jm-dynamic-content-area');
            if (!container) return;

            // å®šä¹‰å“ªäº›å­—æ®µæ˜¯å¤´éƒ¨ä¿¡æ¯ï¼Œéœ€è¦è¢«æ’é™¤
            const HEADER_FIELDS = new Set(['Name', 'Location', 'Time']);

            // æ”¶é›†æ‰€æœ‰éœ€è¦æ¸²æŸ“çš„å­—æ®µï¼Œå¹¶ä¿æŒåŸå§‹é¡ºåº
            const itemsToRender = Object.keys(data)
              .filter(key =>
                !HEADER_FIELDS.has(key) && // æ’é™¤å¤´éƒ¨å­—æ®µ
                typeof data[key] !== 'object' || Array.isArray(data[key]) // æ’é™¤å¯¹è±¡ï¼ˆç•™ç»™Tabï¼‰ï¼Œä½†ä¿ç•™æ•°ç»„
              )
              .map(key => {
                // ä»é…ç½®ä¸­è·å–æ ‡ç­¾ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨å­—æ®µå
                const config = DYNAMIC_CONTENT_CONFIG[key];
                return {
                  key,
                  label: config ? config.label : key,
                  value: data[key],
                };
              });

            // ç”¨äºæ”¶é›†æ‰€æœ‰ stat é¡¹ï¼Œä»¥ä¾¿ç»Ÿä¸€æ¸²æŸ“
            const statItems = [];
            let dynamicHtml = '';

            itemsToRender.forEach(item => {
              let type = 'narrative'; // é»˜è®¤ç±»å‹
              let value = item.value;

              // è‡ªåŠ¨æ£€æµ‹UIç±»å‹
              if (typeof value === 'string' && parseStat(value)) {
                type = 'stat';
              } else if (Array.isArray(value)) {
                type = 'list';
              }

              if (type === 'stat') {
                statItems.push(item);
              } else {
                // å¦‚æœé‡åˆ°é stat é¡¹ï¼Œä¸”ä¹‹å‰æœ‰ stat é¡¹ï¼Œåˆ™å…ˆæ¸²æŸ“ stat å®¹å™¨
                if (statItems.length > 0) {
                  dynamicHtml += `<div class="core-stats">${statItems.map(statItem => renderStat(statItem.label, statItem.value)).join('')}</div>`;
                  statItems.length = 0; // æ¸…ç©º stat é¡¹
                }
                // æ¸²æŸ“å½“å‰é¡¹
                switch (type) {
                  case 'narrative':
                    dynamicHtml += renderNarrative(item.label, item.value);
                    break;
                  case 'list':
                    dynamicHtml += renderList(item.label, item.value);
                    break;
                }
              }
            });

            // ç¡®ä¿æœ€åçš„ stat é¡¹ä¹Ÿè¢«æ¸²æŸ“
            if (statItems.length > 0) {
              dynamicHtml += `<div class="core-stats">${statItems.map(statItem => renderStat(statItem.label, statItem.value)).join('')}</div>`;
            }

            container.innerHTML = dynamicHtml;
          }

          async function updatePortrait(data) {
            const portraitImg = panel.querySelector('[data-field="portrait"]');
            if (!portraitImg) return;

            // ç»Ÿä¸€ç®¡ç†äº‹ä»¶ç›‘å¬å™¨ï¼Œå…ˆç§»é™¤æ—§çš„
            if (portraitClickListener) {
              portraitImg.removeEventListener('click', portraitClickListener);
              portraitClickListener = null;
            }

            const charName = safeGet(data, 'Name', '');
            const storageKey = `jm_user_portrait_${charName}`;

            try {
              const savedPortraitBlob = await idbHelper.get(storageKey);
              if (savedPortraitBlob) {
                const objectURL = URL.createObjectURL(savedPortraitBlob);
                portraitImg.src = objectURL;
                // æµè§ˆå™¨åŠ è½½åç«‹å³é‡Šæ”¾ï¼Œé¿å…å†…å­˜æ³„æ¼
                portraitImg.onload = () => URL.revokeObjectURL(portraitImg.src);

                portraitClickListener = () => {
                  // æ¯æ¬¡ç‚¹å‡»éƒ½åˆ›å»ºä¸€ä¸ªæ–°çš„URLç»™ç”»å»Šä½¿ç”¨
                  const galleryURL = URL.createObjectURL(savedPortraitBlob);
                  openGallery([galleryURL], 0, '');
                };
                portraitImg.addEventListener('click', portraitClickListener);
                return; // æ‰¾åˆ°ç”¨æˆ·å¤´åƒåï¼Œç»ˆæ­¢å‡½æ•°
              }
            } catch (error) {
              console.error('ä» IndexedDB åŠ è½½å¤´åƒå¤±è´¥:', error);
            }

            const occupationText = safeGet(data, 'Status.Occupation', '');
            const nameText = safeGet(data, 'Name', '');
            const textToSearch = occupationText + ' ' + nameText;

            let matchedImages = [];

            if (textToSearch.trim() && allKeywords) {
              // 1. æ‰¾åˆ°æ‰€æœ‰ç²¾ç¡®åŒ¹é…çš„å…³é”®è¯
              let potentialKeywords = allKeywords.filter(k => textToSearch.includes(k));
              potentialKeywords = potentialKeywords.filter(
                shortMatch =>
                  !potentialKeywords.some(
                    longMatch => longMatch.length > shortMatch.length && longMatch.includes(shortMatch),
                  ),
              );

              // 2. å°†å…³é”®è¯åˆ†ä¸ºâ€œå¤´åƒâ€å’Œâ€œæ¦‚å¿µâ€ä¸¤ç±»
              const portraitKeywords = potentialKeywords.filter(k => {
                const mainKeyword = synonymMap[k] || k;
                const imageList = imageIndex[mainKeyword] || [];
                return Array.isArray(imageList) && !imageList.includes('éå¤´åƒ.abc');
              });

              const conceptKeywords = potentialKeywords.filter(k => {
                const mainKeyword = synonymMap[k] || k;
                const imageList = imageIndex[mainKeyword] || [];
                return Array.isArray(imageList) && imageList.includes('éå¤´åƒ.abc');
              });

              // 3. ä¼˜å…ˆä½¿ç”¨â€œå¤´åƒâ€ç±»å…³é”®è¯ï¼Œå¦åˆ™ä½¿ç”¨â€œæ¦‚å¿µâ€ç±»ä½œä¸ºåå¤‡
              const keywordsToUse = portraitKeywords.length > 0 ? portraitKeywords : conceptKeywords;

              // 4. æŒ‰å‡ºç°é¡ºåºæ’åºå¹¶æå–å›¾ç‰‡
              if (keywordsToUse.length > 0) {
                keywordsToUse.sort((a, b) => textToSearch.indexOf(a) - textToSearch.indexOf(b));
                for (const keyword of keywordsToUse) {
                  const mainKeyword = synonymMap[keyword] || keyword;
                  const imageList = imageIndex[mainKeyword] || [];
                  if (Array.isArray(imageList)) {
                    const filtered = imageList.filter(img => img !== 'éå¤´åƒ.abc');
                    matchedImages = matchedImages.concat(filtered);
                  }
                }
                matchedImages = uniq(matchedImages);
              }
            }

            // 5. æ›´æ–°å›¾ç‰‡æºæˆ–ä½¿ç”¨å¤‡ç”¨å¤´åƒ
            if (matchedImages.length > 0) {
              portraitImg.src = GITHUB_BASE_URL + matchedImages[0];
              portraitClickListener = () => openGallery(matchedImages, 0, GITHUB_BASE_URL);
              portraitImg.addEventListener('click', portraitClickListener);
            } else if (fallbackAvatars.length > 0) {
              const charName = safeGet(data, 'Name', 'default');
              const fallbackIndex = getDeterministicRandomIndex(charName, fallbackAvatars.length);
              const fallbackAvatar = fallbackAvatars[fallbackIndex];
              const FACE_BASE_URL = GITHUB_BASE_URL.replace('/jm/', '/face/');
              portraitImg.src = FACE_BASE_URL + fallbackAvatar;
              portraitClickListener = () => openGallery([fallbackAvatar], 0, FACE_BASE_URL);
              portraitImg.addEventListener('click', portraitClickListener);
            } else {
              portraitImg.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
            }
          }


          function openGallery(images, startIndex, baseUrl) {
            const gallery = document.getElementById('jm-image-gallery-1');
            const prevArrow = gallery.querySelector('.gallery-prev');
            const nextArrow = gallery.querySelector('.gallery-next');

            currentGalleryImages = images;
            currentGalleryIndex = startIndex;
            currentGalleryBaseUrl = baseUrl; // è®¾ç½®å½“å‰å›¾åº“çš„åŸºç¡€URL
            updateGalleryImage();
            gallery.style.display = 'flex';

            // æ ¹æ®å›¾ç‰‡æ•°é‡å†³å®šæ˜¯å¦æ˜¾ç¤ºç®­å¤´
            if (currentGalleryImages.length <= 1) {
              prevArrow.style.display = 'none';
              nextArrow.style.display = 'none';
            } else {
              prevArrow.style.display = 'block';
              nextArrow.style.display = 'block';
            }
          }

          function updateGalleryImage() {
            if (currentGalleryImages.length > 0) {
              const galleryImage = panel.querySelector('.gallery-image');
              galleryImage.src = currentGalleryBaseUrl + currentGalleryImages[currentGalleryIndex];
              // é‡ç½®ç¼©æ”¾å’Œä½ç½®
              galleryImage.style.transform = 'scale(1) translate(0, 0)';
            }
          }

          function setupPortraitUpload(data) {
            const uploadTrigger = panel.querySelector('.portrait-upload-trigger');
            const resetTrigger = panel.querySelector('.portrait-reset-trigger');
            const uploadInput = panel.querySelector('#jm-portrait-upload');
            const portraitImg = panel.querySelector('[data-field="portrait"]');

            if (!uploadTrigger || !uploadInput || !portraitImg || !resetTrigger) return;

            const charName = safeGet(data, 'Name', '');
            const storageKey = `jm_user_portrait_${charName}`;

            // å¼‚æ­¥æ£€æŸ¥ IndexedDB ä¸­æ˜¯å¦å­˜åœ¨å¤´åƒï¼Œå¹¶æ›´æ–°é‡ç½®æŒ‰é’®çŠ¶æ€
            (async () => {
              try {
                if (await idbHelper.get(storageKey)) {
                  resetTrigger.style.display = 'flex';
                } else {
                  resetTrigger.style.display = 'none';
                }
              } catch (e) {
                console.error('æ£€æŸ¥å¤´åƒæ˜¯å¦å­˜åœ¨æ—¶å‡ºé”™:', e);
                resetTrigger.style.display = 'none';
              }
            })();

            uploadTrigger.onclick = () => uploadInput.click();

            resetTrigger.onclick = async () => {
              try {
                await idbHelper.delete(storageKey);
                resetTrigger.style.display = 'none';
                portraitImg.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
                await updatePortrait(jsonData); // é‡æ–°åŠ è½½é»˜è®¤å¤´åƒ
              } catch (error) {
                alert(`æ— æ³•é‡ç½®å¤´åƒ: ${error.name}: ${error.message}`);
              }
            };

            uploadInput.onchange = event => {
              const file = event.target.files?.[0];
              if (!file) {
                uploadInput.value = '';
                return;
              }

              if (file.size > 1000 * 1024) {
                alert('å›¾ç‰‡æ–‡ä»¶å¤ªå¤§ (æœ€å¤§ 1000KB)ã€‚è¯·é€‰æ‹©ä¸€å¼ å°ä¸€ç‚¹çš„å›¾ç‰‡ï¼Œæˆ–ä½¿ç”¨å›¾ç‰‡å‹ç¼©å·¥å…·ã€‚');
                uploadInput.value = '';
                return;
              }

              const reader = new FileReader();
              reader.onload = e => {
                const img = new Image();
                img.onload = () => {
                  const canvas = document.createElement('canvas');
                  let { width, height } = img;
                  const maxSize = 400;

                  if (width > height && width > maxSize) {
                    height = (height * maxSize) / width;
                    width = maxSize;
                  } else if (height > maxSize) {
                    width = (width * maxSize) / height;
                    height = maxSize;
                  }

                  canvas.width = width;
                  canvas.height = height;
                  const ctx = canvas.getContext('2d');
                  ctx.drawImage(img, 0, 0, width, height);

                  // å°† Canvas å†…å®¹è½¬æ¢ä¸º Blob å¯¹è±¡ï¼Œè€Œä¸æ˜¯ Base64
                  canvas.toBlob(
                    async blob => {
                      if (!blob) {
                        alert('å›¾ç‰‡å¤„ç†å¤±è´¥ï¼Œæ— æ³•åˆ›å»º Blob å¯¹è±¡ã€‚');
                        uploadInput.value = '';
                        return;
                      }

                      if (blob.size > 800 * 1024) {
                        alert('å‹ç¼©åçš„å›¾ç‰‡ä»ç„¶å¤ªå¤§ã€‚è¯·é€‰æ‹©ä¸€å¼ æ›´å°çš„å›¾ç‰‡ã€‚');
                        uploadInput.value = '';
                        return;
                      }

                      try {
                        await idbHelper.set(storageKey, blob);
                        await updatePortrait(jsonData); // é‡æ–°åŠ è½½å¤´åƒä»¥åº”ç”¨æ›´æ”¹å’Œäº‹ä»¶
                        resetTrigger.style.display = 'flex';
                        console.log(`å¤´åƒå·²ä¿å­˜ï¼Œå‹ç¼©åå¤§å°çº¦ ${Math.round(blob.size / 1024)}KB`);
                      } catch (error) {
                        console.error('ä¿å­˜å¤´åƒåˆ° IndexedDB å¤±è´¥:', error);
                        if (error.name === 'QuotaExceededError') {
                          alert(
                            'æµè§ˆå™¨å­˜å‚¨ç©ºé—´ä¸è¶³ã€‚IndexedDB ä¹Ÿå·²æ»¡ã€‚\nè¯·æ¸…ç†æµè§ˆå™¨æ•°æ®æˆ–ä½¿ç”¨æ›´å°çš„å›¾ç‰‡ã€‚',
                          );
                        } else {
                          alert(`å¤´åƒä¿å­˜å¤±è´¥: ${error.message}`);
                        }
                      } finally {
                        uploadInput.value = ''; // æ— è®ºæˆåŠŸå¤±è´¥éƒ½æ¸…ç©ºï¼Œä»¥ä¾¿å†æ¬¡é€‰æ‹©åŒä¸ªæ–‡ä»¶
                      }
                    },
                    'image/jpeg',
                    0.7,
                  );
                };
                img.onerror = () => {
                  alert('æ— æ³•åŠ è½½æ‰€é€‰æ–‡ä»¶ï¼Œå¯èƒ½ä¸æ˜¯æœ‰æ•ˆçš„å›¾ç‰‡æ ¼å¼ã€‚');
                  uploadInput.value = '';
                };
                img.src = e.target.result;
              };
              reader.onerror = () => {
                alert('è¯»å–æ–‡ä»¶å¤±è´¥ã€‚');
                uploadInput.value = '';
              };
              reader.readAsDataURL(file);
            };
          }

          function setupEventListeners() {
            // æŠ˜å /å±•å¼€åŠŸèƒ½
            const collapseToggle = panel.querySelector('.collapse-toggle');
            if (collapseToggle) {
              collapseToggle.addEventListener('click', () => {
                panel.classList.toggle('collapsed');
              });
            }

            // ä½¿ç”¨äº‹ä»¶å§”æ‰˜ï¼Œé«˜æ•ˆå¤„ç†æ‰€æœ‰å›¾ç‰‡é“¾æ¥ç‚¹å‡»
            panel.addEventListener('click', function (e) {
              const link = e.target.closest('.image-link');
              if (link) {
                e.preventDefault();
                const keyword = link.dataset.keyword;
                if (keyword) {
                  const matchedImages = findImagesByKeyword(keyword);
                  if (matchedImages.length > 0) {
                    openGallery(matchedImages, 0, GITHUB_BASE_URL);
                  }
                }
              }
            });

            document.querySelectorAll('.tab-button').forEach(button => {
              button.addEventListener('click', () => {
                const targetTabId = button.dataset.tab;
                document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                button.classList.add('active');
                document.getElementById(targetTabId).classList.add('active');
              });
            });
            const gallery = document.getElementById('jm-image-gallery-1');
            gallery.querySelector('.gallery-close').addEventListener('click', () => {
              const galleryImage = gallery.querySelector('.gallery-image');
              // å¦‚æœæ˜¯ Object URL, é‡Šæ”¾å®ƒä»¥é˜²æ­¢å†…å­˜æ³„æ¼
              if (galleryImage.src.startsWith('blob:')) {
                URL.revokeObjectURL(galleryImage.src);
              }
              gallery.style.display = 'none';
            });
            gallery.querySelector('.gallery-prev').addEventListener('click', () => {
              currentGalleryIndex =
                (currentGalleryIndex - 1 + currentGalleryImages.length) % currentGalleryImages.length;
              updateGalleryImage();
            });
            gallery.querySelector('.gallery-next').addEventListener('click', () => {
              currentGalleryIndex = (currentGalleryIndex + 1) % currentGalleryImages.length;
              updateGalleryImage();
            });

            // --- æ–°å¢ï¼šå›¾ç‰‡ç¼©æ”¾å’Œæ‹–åŠ¨åŠŸèƒ½ ---
            const galleryImage = gallery.querySelector('.gallery-image');
            let isDragging = false;
            let startX,
              startY,
              lastX = 0,
              lastY = 0;
            let scale = 1;
            let lastTouchDistance = null;

            // --- æ¡Œé¢ç«¯ï¼šé¼ æ ‡äº‹ä»¶ ---
            galleryImage.addEventListener('wheel', e => {
              e.preventDefault();
              const rect = galleryImage.getBoundingClientRect();
              const offsetX = e.clientX - rect.left;
              const offsetY = e.clientY - rect.top;

              const oldScale = scale;
              scale += e.deltaY * -0.001;
              scale = Math.min(Math.max(0.5, scale), 5);

              lastX = offsetX - (offsetX - lastX) * (scale / oldScale);
              lastY = offsetY - (offsetY - lastY) * (scale / oldScale);

              updateTransform();
            });

            galleryImage.addEventListener('mousedown', e => {
              e.preventDefault();
              isDragging = true;
              galleryImage.classList.add('dragging');
              startX = e.pageX - lastX;
              startY = e.pageY - lastY;
            });

            galleryImage.addEventListener('mouseleave', () => {
              isDragging = false;
              galleryImage.classList.remove('dragging');
            });

            galleryImage.addEventListener('mouseup', () => {
              isDragging = false;
              galleryImage.classList.remove('dragging');
            });

            galleryImage.addEventListener('mousemove', e => {
              if (isDragging) {
                e.preventDefault();
                lastX = e.pageX - startX;
                lastY = e.pageY - startY;
                updateTransform();
              }
            });

            galleryImage.addEventListener('dblclick', () => {
              resetTransform();
            });

            // --- ç§»åŠ¨ç«¯ï¼šè§¦æ‘¸äº‹ä»¶ ---
            galleryImage.addEventListener('touchstart', e => {
              if (e.touches.length === 1) {
                isDragging = true;
                galleryImage.classList.add('dragging');
                startX = e.touches.pageX - lastX;
                startY = e.touches.pageY - lastY;
              } else if (e.touches.length === 2) {
                isDragging = false; // æåˆæ—¶åœæ­¢æ‹–åŠ¨
                lastTouchDistance = Math.hypot(e.touches.pageX - e.touches.pageX, e.touches.pageY - e.touches.pageY);
              }
            });

            galleryImage.addEventListener('touchend', e => {
              isDragging = false;
              galleryImage.classList.remove('dragging');
              lastTouchDistance = null;
            });

            galleryImage.addEventListener('touchmove', e => {
              e.preventDefault();
              if (isDragging && e.touches.length === 1) {
                lastX = e.touches.pageX - startX;
                lastY = e.touches.pageY - startY;
                updateTransform();
              } else if (e.touches.length === 2 && lastTouchDistance) {
                const rect = galleryImage.getBoundingClientRect();
                const touch1 = { x: e.touches.pageX, y: e.touches.pageY };
                const touch2 = { x: e.touches.pageX, y: e.touches.pageY };
                const centerX = (touch1.x + touch2.x) / 2 - rect.left;
                const centerY = (touch1.y + touch2.y) / 2 - rect.top;

                const newTouchDistance = Math.hypot(touch1.x - touch2.x, touch1.y - touch2.y);

                const oldScale = scale;
                const scaleChange = newTouchDistance / lastTouchDistance;
                scale *= scaleChange;
                scale = Math.min(Math.max(0.5, scale), 5);
                lastTouchDistance = newTouchDistance;

                lastX = centerX - (centerX - lastX) * (scale / oldScale);
                lastY = centerY - (centerY - lastY) * (scale / oldScale);

                updateTransform();
              }
            });

            function updateTransform() {
              // åªæœ‰å½“ç¼©æ”¾å¤§äº1æ—¶æ‰åº”ç”¨ä½ç§»
              const canPan = scale > 1;
              const translateX = canPan ? lastX : 0;
              const translateY = canPan ? lastY : 0;
              if (!canPan) {
                lastX = 0;
                lastY = 0;
              }
              galleryImage.style.transform = `scale(${scale}) translate(${translateX}px, ${translateY}px)`;
            }

            function resetTransform() {
              scale = 1;
              lastX = 0;
              lastY = 0;
              updateTransform();
            }
            setupPortraitUpload(jsonData);
          }

          async function main() {
            updatePanel(jsonData);
            // è®¾ç½®é»˜è®¤æŠ˜å çŠ¶æ€
            panel.classList.add('collapsed');
            
            const dataLoaded = await fetchData();
            if (dataLoaded) {
              await updatePortrait(jsonData); // ç­‰å¾…å¤´åƒåŠ è½½å®Œæˆ
              linkifyAllText();
            } else {
              console.warn(`[çŠ¶æ€æ  ${panel.id}] æ— æ³•åŠ è½½å›¾ç‰‡ç´¢å¼•ï¼Œå›¾ç‰‡ç›¸å…³åŠŸèƒ½å°†ä¸å¯ç”¨ã€‚`);
            }
            setupEventListeners();
          }

          main();
        } catch (error) {
          displayError(
            'è„šæœ¬æ‰§è¡Œå¤±è´¥ã€‚è¿™é€šå¸¸æ˜¯ç”±äºAIè¾“å‡ºçš„JSONæ ¼å¼ä¸æ­£ç¡®å¯¼è‡´çš„ã€‚',
            `é”™è¯¯ä¿¡æ¯: ${error.message}. æ•è·åˆ°çš„åŸå§‹æ•°æ®: ${rawData}`,
          );
        }
      });
    </script>
  </body>
</html>

```