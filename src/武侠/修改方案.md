# 武侠地图系统 + 指令队列 + 物品使用 实现计划

## 需求概述

1. **古地图风格**的三级地点系统（大区域 → 中区域 → 小地点）
2. **YAML数据驱动**，支持未探索状态
3. **指令队列系统**：点击地点/物品后生成指令，可撤销
4. **独立地图编辑器**：标注地点坐标，生成JSON
5. **物品使用**：点击物品生成使用指令，自动扣减数量

---

## 用户选择确认

- ✅ 指令队列位置：**发送按钮旁边（小按钮）**
- ✅ 物品扣减时机：**点击物品时立即扣减**（取消指令时回退）
- ✅ 地图编辑器形式：**独立的HTML页面**
- ✅ 坐标系统：**像素坐标**（直接使用图片像素位置）

---

## 核心设计方案

### 1. 数据结构

#### 1.1 地图数据（`data/地图数据.json`）

```json
{
  "大漠": {
    "描述": "黄沙漫天，驼铃声声",
    "类型": "大区域",
    "坐标": { "x": 200, "y": 150 },
    "子区域": {
      "草原": {
        "描述": "水草丰美，牛羊成群",
        "类型": "中区域",
        "坐标": { "x": 220, "y": 130 },
        "地点": {
          "郭靖家茅屋": {
            "描述": "一座简陋的蒙古包",
            "坐标": { "x": 230, "y": 120 },
            "初始探索": true
          },
          "铁木真帐篷": {
            "描述": "金帐汗王的营地",
            "坐标": { "x": 240, "y": 140 },
            "初始探索": false,
            "解锁条件": "完成草原初遇事件"
          }
        }
      }
    }
  }
}
```

#### 1.2 酒馆变量存储

```yaml
stat_data:
  user数据:
    所在位置: "大漠/草原/郭靖家茅屋"  # 现有字段
    已探索地点:  # 新增字段
      - "大漠/草原/郭靖家茅屋"
      - "大宋/临安府/牛家村"
    包裹:  # 现有字段
      "金创药":
        类型: "丹药"
        品质: "精品"
        数量: 3
        物品描述: "疗伤圣药"
```

#### 1.3 TypeScript 类型（添加到 `types.ts`）

```typescript
// 地图相关类型
export interface MapCoordinate {
  x: number;
  y: number;
}

export interface MapLocation {
  描述: string;
  坐标: MapCoordinate;
  初始探索: boolean;
  解锁条件?: string;
  关联事件?: string[];
}

export interface MapRegion {
  描述: string;
  类型: '中区域';
  坐标: MapCoordinate;
  地点: Record<string, MapLocation>;
}

export interface MapArea {
  描述: string;
  类型: '大区域';
  坐标: MapCoordinate;
  子区域: Record<string, MapRegion>;
}

export interface MapData {
  [areaName: string]: MapArea;
}

// 指令队列相关类型
export interface PendingCommand {
  id: string;
  type: 'TRAVEL' | 'USE_ITEM';
  text: string;
  data: {
    // 前往地点
    location?: string;
    // 使用物品
    itemName?: string;
    originalCount?: number; // 用于撤销
  };
  timestamp: number;
}

// CharacterProfile 接口新增字段
export interface CharacterProfile {
  // ... 现有字段
  已探索地点?: string[];
}
```

---

### 2. 组件架构

#### 2.1 地图系统组件

```
MapPanel.tsx (主容器)
├── MapCanvas.tsx (古地图背景 + SVG标记点)
│   ├── MapBackground (泛黄纸张纹理)
│   └── LocationMarkers (可点击标记点)
├── MapSidebar.tsx (三级折叠列表)
│   ├── AreaSection (大区域)
│   ├── RegionSection (中区域)
│   └── LocationItem (小地点)
└── LocationDetails.tsx (选中地点详情)
```

#### 2.2 指令队列组件

```
CommandQueueButton.tsx (ChatInput 旁边的小按钮)
└── CommandQueuePopover.tsx (点击后弹出的浮窗)
    └── CommandCard.tsx (单个指令卡片，带取消按钮)
```

#### 2.3 物品系统增强

修改现有 `InventoryPanel.tsx`：
- 点击物品 → 立即扣减数量 → 生成使用指令
- 点击指令取消按钮 → 恢复物品数量

---

### 3. 核心功能实现

#### 3.1 指令队列管理（新建 `hooks/useCommandQueue.ts`）

```typescript
export function useCommandQueue() {
  const [commands, setCommands] = useState<PendingCommand[]>([]);

  // 添加前往地点指令
  const addTravelCommand = (location: string) => {
    const command: PendingCommand = {
      id: `travel_${Date.now()}`,
      type: 'TRAVEL',
      text: `前往${location.split('/').pop()}`,
      data: { location },
      timestamp: Date.now()
    };
    setCommands(prev => [...prev, command]);
  };

  // 添加使用物品指令
  const addUseItemCommand = (itemName: string, originalCount: number) => {
    const command: PendingCommand = {
      id: `use_${Date.now()}`,
      type: 'USE_ITEM',
      text: `使用${itemName}`,
      data: { itemName, originalCount },
      timestamp: Date.now()
    };
    setCommands(prev => [...prev, command]);
  };

  // 取消指令
  const cancelCommand = (commandId: string) => {
    const command = commands.find(c => c.id === commandId);
    if (command?.type === 'USE_ITEM') {
      // 恢复物品数量
      restoreItemCount(command.data.itemName!, command.data.originalCount!);
    }
    setCommands(prev => prev.filter(c => c.id !== commandId));
  };

  // 发送所有指令
  const sendAllCommands = async () => {
    const message = commands.map(c => c.text).join('，');
    await handleSendMessage(message);
    setCommands([]);
  };

  return {
    commands,
    addTravelCommand,
    addUseItemCommand,
    cancelCommand,
    sendAllCommands
  };
}
```

#### 3.2 物品数量管理（新建 `utils/itemManager.ts`）

```typescript
// 扣减物品数量
export async function decreaseItemCount(itemName: string, count: number = 1) {
  const variables = getAllVariables();
  const currentCount = variables.stat_data?.user数据?.包裹?.[itemName]?.数量 || 0;
  const newCount = Math.max(0, currentCount - count);

  if (newCount === 0) {
    // 数量为0，删除物品
    await eventEmit('era:deleteByPath', {
      path: `stat_data.user数据.包裹.${itemName}`
    });
  } else {
    // 更新数量
    await eventEmit('era:updateByObject', {
      stat_data: {
        user数据: {
          包裹: {
            [itemName]: { 数量: newCount }
          }
        }
      }
    });
  }

  return newCount;
}

// 恢复物品数量（撤销用）
export async function restoreItemCount(itemName: string, originalCount: number) {
  await eventEmit('era:updateByObject', {
    stat_data: {
      user数据: {
        包裹: {
          [itemName]: { 数量: originalCount }
        }
      }
    }
  });
}
```

#### 3.3 地点解锁检查（新建 `utils/mapUtils.ts`）

```typescript
export function isLocationUnlocked(
  locationPath: string,
  location: MapLocation,
  gameState: GameState
): boolean {
  // 已探索的地点
  if (gameState.stats.已探索地点?.includes(locationPath)) {
    return true;
  }

  // 初始就探索的地点
  if (location.初始探索) {
    return true;
  }

  // 无解锁条件的地点
  if (!location.解锁条件) {
    return true;
  }

  // TODO: 实现复杂的解锁条件检查（事件触发、境界达到等）
  return false;
}
```

---

### 4. UI 样式设计（古地图风格）

#### 4.1 地图背景（添加到 `_panels.scss`）

```scss
.map-container {
  width: 100%;
  height: 100%;
  display: grid;
  grid-template-columns: 250px 1fr;
  gap: 1rem;
  position: relative;
  background: linear-gradient(
    135deg,
    rgba(250, 240, 220, 0.95),
    rgba(245, 235, 215, 0.9)
  );
  filter: sepia(20%);
}

.map-canvas {
  position: relative;
  width: 100%;
  height: 100%;
  background-image:
    radial-gradient(circle at 30% 20%, rgba(139, 90, 43, 0.08) 0%, transparent 40%),
    radial-gradient(circle at 70% 60%, rgba(139, 90, 43, 0.06) 0%, transparent 35%);

  svg {
    width: 100%;
    height: 100%;
  }
}

// 地点标记点
.location-marker {
  cursor: pointer;
  transition: all 0.3s ease;

  &.explored {
    circle {
      fill: #8b5a2b;
      filter: drop-shadow(0 0 4px rgba(139, 90, 43, 0.5));
    }
    text {
      fill: #44403c;
      font-family: var(--font-serif);
      font-size: 12px;
    }
  }

  &.unexplored {
    circle {
      fill: #a8a29e;
      opacity: 0.4;
    }
  }

  &.current {
    animation: markerPulse 2s ease-in-out infinite;
  }

  &:hover.explored {
    circle {
      filter: drop-shadow(0 0 8px rgba(212, 175, 55, 0.8));
    }
  }
}

@keyframes markerPulse {
  0%, 100% {
    filter: drop-shadow(0 0 6px rgba(212, 175, 55, 0.6));
  }
  50% {
    filter: drop-shadow(0 0 12px rgba(212, 175, 55, 0.9));
  }
}
```

#### 4.2 指令队列按钮（添加到 `_chat.scss`）

```scss
.command-queue-btn {
  width: 36px;
  height: 36px;
  flex-shrink: 0;
  background: linear-gradient(135deg, rgba(28, 25, 23, 0.6), rgba(41, 37, 36, 0.4));
  border: 1px solid rgba(181, 137, 80, 0.3);
  border-radius: 6px;
  cursor: pointer;
  position: relative;
  transition: all 0.3s ease;

  &:hover {
    border-color: rgba(212, 175, 55, 0.6);
    box-shadow: 0 0 12px rgba(181, 137, 80, 0.3);
  }

  // 指令数量徽章
  .command-count {
    position: absolute;
    top: -6px;
    right: -6px;
    width: 18px;
    height: 18px;
    background: #d97706;
    border-radius: 50%;
    font-size: 10px;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
  }
}

.command-queue-popover {
  position: absolute;
  bottom: calc(100% + 8px);
  right: 0;
  width: 320px;
  max-height: 400px;
  background: #1c1917;
  border: 1px solid rgba(181, 137, 80, 0.3);
  border-radius: 8px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
  padding: 1rem;
  z-index: 100;

  .command-card {
    background: rgba(255, 255, 255, 0.03);
    border: 1px solid rgba(255, 255, 255, 0.08);
    border-radius: 6px;
    padding: 0.75rem;
    margin-bottom: 0.5rem;
    display: flex;
    justify-content: space-between;
    align-items: center;

    .command-text {
      flex: 1;
      color: var(--stone-300);
      font-size: 0.9rem;
    }

    .cancel-btn {
      width: 24px;
      height: 24px;
      border: none;
      background: transparent;
      color: var(--stone-600);
      cursor: pointer;

      &:hover {
        color: var(--stone-300);
      }
    }
  }
}
```

---

### 5. 地图编辑器设计（独立HTML页面）

#### 5.1 文件结构

```
tools/
└── map-editor.html  (单文件，包含HTML+CSS+JS)
```

#### 5.2 功能设计

1. **上传背景图**：选择东亚地形图片
2. **加载YAML**：导入现有的地图数据YAML
3. **点击标注**：
   - 选择层级（大区域/中区域/小地点）
   - 输入名称和描述
   - 点击图片位置，自动记录像素坐标
4. **导出JSON**：生成 `地图数据.json` 文件
5. **预览模式**：查看所有标记点

#### 5.3 核心代码结构

```html
<!DOCTYPE html>
<html>
<head>
  <title>武侠地图编辑器</title>
  <style>
    /* 编辑器样式 */
  </style>
</head>
<body>
  <div class="editor-container">
    <div class="toolbar">
      <input type="file" id="imageUpload" accept="image/*">
      <input type="file" id="yamlUpload" accept=".yaml,.yml,.json">
      <select id="levelSelect">
        <option value="area">大区域</option>
        <option value="region">中区域</option>
        <option value="location">小地点</option>
      </select>
      <button id="exportBtn">导出JSON</button>
    </div>

    <div class="canvas-wrapper">
      <canvas id="mapCanvas"></canvas>
    </div>

    <div class="sidebar">
      <h3>地点列表</h3>
      <div id="locationList"></div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
  <script>
    // 编辑器逻辑
    const canvas = document.getElementById('mapCanvas');
    const ctx = canvas.getContext('2d');
    let mapData = {};
    let backgroundImage = null;

    // 点击画布记录坐标
    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = Math.round(e.clientX - rect.left);
      const y = Math.round(e.clientY - rect.top);

      const name = prompt('请输入地点名称：');
      if (name) {
        addLocation(name, x, y);
      }
    });

    // 导出JSON
    document.getElementById('exportBtn').addEventListener('click', () => {
      const json = JSON.stringify(mapData, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = '地图数据.json';
      a.click();
    });
  </script>
</body>
</html>
```

---

## 实现步骤

### Phase 1: 数据层（1-2小时）

1. ✅ 在 `types.ts` 添加地图和指令队列类型定义
2. ✅ 创建 `data/地图数据.json`（初始数据）
3. ✅ 创建 `utils/mapUtils.ts`（地点解锁检查）
4. ✅ 创建 `utils/itemManager.ts`（物品数量管理）
5. ✅ 创建 `hooks/useCommandQueue.ts`（指令队列管理）

### Phase 2: 地图系统（3-4小时）

6. ✅ 重构 `MapPanel.tsx`（加载地图数据，管理UI状态）
7. ✅ 创建 `MapCanvas.tsx`（SVG渲染标记点）
8. ✅ 创建 `MapSidebar.tsx`（三级折叠列表）
9. ✅ 在 `_panels.scss` 添加古地图样式

### Phase 3: 指令队列（2-3小时）

10. ✅ 创建 `CommandQueueButton.tsx`（ChatInput 旁边的小按钮）
11. ✅ 创建 `CommandQueuePopover.tsx`（指令列表浮窗）
12. ✅ 修改 `ChatInput.tsx`（集成指令队列按钮）
13. ✅ 在 `_chat.scss` 添加指令队列样式

### Phase 4: 物品系统增强（1-2小时）

14. ✅ 修改 `InventoryPanel.tsx`（点击物品 → 扣减 → 生成指令）
15. ✅ 实现物品数量撤销机制

### Phase 6: 集成与测试（1-2小时）

16. ✅ 在 `App.tsx` 集成指令队列到全局状态
17. ✅ 在 `variableReader.ts` 添加已探索地点读取
18. ✅ 测试地点点击 → 生成指令 → 发送消息流程
19. ✅ 测试物品使用 → 扣减 → 撤销流程

### Phase 5: 地图编辑器（2-3小时）

20. ✅ 创建 `tools/map-editor.html`（独立HTML页面）
21. ✅ 实现图片上传和坐标标注
22. ✅ 实现YAML/JSON导入导出
23. ✅ 添加使用说明文档

---

## 关键文件清单

### 需要创建的新文件

- `src/武侠/data/地图数据.json` - 地图数据
- `src/武侠/utils/mapUtils.ts` - 地图工具函数
- `src/武侠/utils/itemManager.ts` - 物品管理工具
- `src/武侠/hooks/useCommandQueue.ts` - 指令队列Hook
- `src/武侠/components/MapCanvas.tsx` - 地图画布组件
- `src/武侠/components/MapSidebar.tsx` - 地图侧边栏组件
- `src/武侠/components/CommandQueueButton.tsx` - 指令队列按钮
- `src/武侠/components/CommandQueuePopover.tsx` - 指令队列浮窗
- `tools/map-editor.html` - 地图编辑器

### 需要修改的现有文件

- `src/武侠/types.ts` - 添加地图和指令队列类型
- `src/武侠/components/panels/MapPanel.tsx` - 完全重写
- `src/武侠/components/panels/InventoryPanel.tsx` - 添加物品使用逻辑
- `src/武侠/components/ChatInput.tsx` - 集成指令队列按钮
- `src/武侠/App.tsx` - 集成指令队列全局状态
- `src/武侠/utils/variableReader.ts` - 添加已探索地点读取
- `src/武侠/styles/_panels.scss` - 添加地图样式
- `src/武侠/styles/_chat.scss` - 添加指令队列样式

---

## 验证测试

### 地图系统测试

1. ✅ 打开地图面板，查看古地图背景是否正确渲染
2. ✅ 点击已探索地点，检查是否生成"前往XX"指令
3. ✅ 点击未探索地点，检查是否无法点击或显示解锁条件
4. ✅ 发送指令后，检查 `stat_data.user数据.所在位置` 是否更新

### 指令队列测试

1. ✅ 点击地点，检查指令队列按钮是否显示数量徽章
2. ✅ 点击指令队列按钮，检查浮窗是否弹出并显示指令列表
3. ✅ 点击指令取消按钮，检查指令是否从列表移除
4. ✅ 点击发送按钮，检查所有指令是否合并发送

### 物品系统测试

1. ✅ 点击物品，检查数量是否立即减1
2. ✅ 检查是否生成"使用XX"指令
3. ✅ 取消指令，检查物品数量是否恢复
4. ✅ 物品数量为0时，检查是否自动从包裹中删除

### 地图编辑器测试

1. ✅ 上传地形图片，检查是否正确显示
2. ✅ 点击图片，检查是否记录正确的像素坐标
3. ✅ 导出JSON，检查格式是否符合预期
4. ✅ 将导出的JSON放入 `data/` 目录，检查前端是否正确加载

---

## 技术难点与解决方案

### 1. 物品数量撤销机制

**难点**：点击物品立即扣减，取消指令时需要恢复原数量

**方案**：
- 在 `PendingCommand.data` 中存储 `originalCount`
- 取消指令时调用 `restoreItemCount(itemName, originalCount)`
- 使用 `era:updateByObject` 更新数量

### 2. 指令队列按钮位置

**难点**：ChatInput 组件布局紧凑，需要在发送按钮旁边插入小按钮

**方案**：
- 修改 `ChatInput.tsx` 的 `.chat-input-container` 布局
- 在发送按钮前插入 `CommandQueueButton`
- 使用 `position: relative` + `position: absolute` 实现浮窗定位

### 3. 古地图背景效果

**难点**：实现泛黄纸张 + 水墨晕染效果

**方案**：
- 使用 `linear-gradient` 叠加多层渐变模拟纸张纹理
- 使用 `radial-gradient` 模拟水墨晕染
- 使用 `filter: sepia()` 增加泛黄效果
- 使用 `mix-blend-mode: multiply` 混合图层

### 4. 地图编辑器坐标系统

**难点**：图片尺寸不固定，如何统一坐标系统

**方案**：
- 使用像素坐标（用户选择）
- 编辑器中 canvas 尺寸与图片尺寸一致
- 前端渲染时使用 SVG viewBox 自动缩放

---

## 后续优化方向

1. **地图缩放/拖拽**：实现地图的缩放和拖拽功能
2. **路径连线**：在地图上绘制地点之间的路径连线
3. **事件标记**：在地图上标记关联事件的位置
4. **动画效果**：地点解锁时的动画效果
5. **多地图支持**：支持切换不同的地图（如中原地图、西域地图）
