# 武侠地图系统 + 指令队列 + 物品使用 实现计划

## 项目概述

为**墨剑录(Ink & Blade)** 武侠RPG系统添加三个核心功能:

1. **古地图风格的三级地点系统** - 大区域→中区域→小地点,支持探索解锁
2. **指令队列系统** - 点击地点/物品生成指令,可撤销,手动发送
3. **物品使用增强** - 点击物品立即扣减数量并生成使用指令

---

## 用户需求确认

基于问答收集的用户偏好:

✅ **地图数据存储**: `data/地图数据.json` (静态JSON文件)
✅ **探索状态存储**: `stat_data.user数据.已探索地点[]` (YAML变量)
✅ **指令队列持久化**: 页面刷新时清空队列
✅ **地图编辑器**: 独立的 `tools/map-editor.html` 页面
✅ **物品使用指令格式**: 简洁格式 `"使用金创药"`
✅ **地点解锁机制**: 基于事件触发 (需在事件系统中添加解锁逻辑)
✅ **指令发送时机**: 仅手动发送 (用户完全控制)
✅ **地图背景**: 真实地形图背景 (需准备东亚地形图片)
✅ **地点点击行为**: 直接生成指令 (无二次确认)
✅ **地图显示层级**: 地图上仅显示前两级 (大区域+中区域标记点)
✅ **第三级地点选择**: 点击中区域标记点后,弹出浮窗列表显示小地点

---

## 核心设计方案

### 1. 数据结构设计

#### 1.1 地图数据 (`data/地图数据.json`)

```json
{
  "大漠": {
    "描述": "黄沙漫天,驼铃声声",
    "类型": "大区域",
    "坐标": { "x": 200, "y": 150 },
    "子区域": {
      "草原": {
        "描述": "水草丰美,牛羊成群",
        "类型": "中区域",
        "坐标": { "x": 220, "y": 130 },
        "地点": {
          "郭靖家茅屋": {
            "描述": "一座简陋的蒙古包",
            "坐标": { "x": 230, "y": 120 },
            "初始探索": true
          },
          "铁木真帐篷": {
            "描述": "金帐汗王的营地",
            "坐标": { "x": 240, "y": 140 },
            "初始探索": false,
            "解锁条件": "完成草原初遇事件"
          }
        }
      }
    }
  }
}
```

**关键字段说明:**

- `坐标`: 像素坐标,用于在地图背景图上标记位置
- `初始探索`: true表示游戏开始时即可见
- `解锁条件`: 字符串描述,需在事件系统中实现检查逻辑

#### 1.2 YAML变量扩展

```yaml
stat_data:
  user数据:
    所在位置: "大漠/草原/郭靖家茅屋"  # 现有字段
    已探索地点:  # 新增字段
      - "大漠/草原/郭靖家茅屋"
      - "大宋/临安府/牛家村"
    包裹:  # 现有字段
      "金创药":
        类型: "丹药"
        品质: "GREEN"
        数量: 3
        物品描述: "疗伤圣药"
```

#### 1.3 TypeScript类型定义 (添加到 `types.ts`)

```typescript
// 地图相关类型
export interface MapCoordinate {
  x: number;
  y: number;
}

export interface MapLocation {
  描述: string;
  坐标: MapCoordinate;
  初始探索: boolean;
  解锁条件?: string;
}

export interface MapRegion {
  描述: string;
  类型: '中区域';
  坐标: MapCoordinate;
  地点: Record<string, MapLocation>;
}

export interface MapArea {
  描述: string;
  类型: '大区域';
  坐标: MapCoordinate;
  子区域: Record<string, MapRegion>;
}

export interface MapData {
  [areaName: string]: MapArea;
}

// 指令队列类型
export interface PendingCommand {
  id: string;
  type: 'TRAVEL' | 'USE_ITEM';
  text: string;
  data: {
    location?: string;
    itemName?: string;
    originalCount?: number; // 用于撤销
  };
  timestamp: number;
}

// CharacterProfile 扩展
export interface CharacterProfile {
  // ... 现有字段
  已探索地点?: string[];
}
```

---

### 2. 组件架构

#### 2.1 地图系统组件

```text
MapPanel.tsx (主容器 - 需重构)
├── MapCanvas.tsx (新建 - 地图画布 + SVG标记点)
│   ├── 背景图层 (真实地形图)
│   ├── SVG标记层 (仅显示大区域+中区域标记点)
│   └── LocationPopover.tsx (新建 - 点击中区域后弹出的小地点列表浮窗)
└── MapSidebar.tsx (新建 - 三级折叠列表,用于侧边栏导航)
    ├── AreaSection (大区域折叠项)
    ├── RegionSection (中区域折叠项)
    └── LocationItem (小地点项)
```

**地图显示层级说明:**

- **地图画布上**: 仅显示前两级标记点 (大区域圆点 + 中区域圆点)
- **点击中区域标记**: 在标记点旁边弹出浮窗,列出该中区域下的所有小地点
- **侧边栏**: 完整的三级折叠列表,用于文字导航

#### 2.2 指令队列组件

```text
CommandQueueButton.tsx (新建 - ChatInput旁边的小按钮)
└── CommandQueuePopover.tsx (新建 - 点击后弹出的浮窗)
    └── CommandCard.tsx (单个指令卡片,带取消按钮)
```

#### 2.3 物品系统增强

修改 `InventoryPanel.tsx`:

- 点击物品 → 调用 `decreaseItemCount()` → 生成使用指令
- 取消指令 → 调用 `restoreItemCount()` 恢复数量

---

### 3. 核心功能实现

#### 3.1 指令队列管理 (`hooks/useCommandQueue.ts`)

**职责:**

- 管理指令队列状态 (内存中,不持久化)
- 添加前往地点指令
- 添加使用物品指令
- 取消指令 (物品类型需恢复数量)
- 发送所有指令

**关键函数:**

```typescript
export function useCommandQueue() {
  const [commands, setCommands] = useState<PendingCommand[]>([]);

  const addTravelCommand = (location: string) => {
    // 生成 "前往XX" 指令
  };

  const addUseItemCommand = (itemName: string, originalCount: number) => {
    // 生成 "使用XX" 指令
  };

  const cancelCommand = (commandId: string) => {
    // 如果是物品使用指令,恢复数量
    // 从队列中移除
  };

  const sendAllCommands = async () => {
    // 合并所有指令文本,调用 handleSendMessage
    // 清空队列
  };

  return { commands, addTravelCommand, addUseItemCommand, cancelCommand, sendAllCommands };
}
```

#### 3.2 物品数量管理 (`utils/itemManager.ts`)

**职责:**

- 扣减物品数量
- 恢复物品数量 (撤销用)
- 处理数量为0时删除物品

**关键函数:**

```typescript
export async function decreaseItemCount(itemName: string, count: number = 1) {
  const variables = getAllVariables();
  const currentCount = variables.stat_data?.user数据?.包裹?.[itemName]?.数量 || 0;
  const newCount = Math.max(0, currentCount - count);

  if (newCount === 0) {
    await eventEmit('era:deleteByPath', {
      path: `stat_data.user数据.包裹.${itemName}`
    });
  } else {
    await eventEmit('era:updateByObject', {
      stat_data: {
        user数据: {
          包裹: {
            [itemName]: { 数量: newCount }
          }
        }
      }
    });
  }

  return newCount;
}

export async function restoreItemCount(itemName: string, originalCount: number) {
  await eventEmit('era:updateByObject', {
    stat_data: {
      user数据: {
        包裹: {
          [itemName]: { 数量: originalCount }
        }
      }
    }
  });
}
```

#### 3.3 地点解锁检查 (`utils/mapUtils.ts`)

**职责:**

- 检查地点是否已解锁
- 支持基于事件触发的解锁机制

**关键函数:**

```typescript
export function isLocationUnlocked(
  locationPath: string,
  location: MapLocation,
  exploredLocations: string[]
): boolean {
  // 1. 已探索的地点
  if (exploredLocations.includes(locationPath)) {
    return true;
  }

  // 2. 初始就探索的地点
  if (location.初始探索) {
    return true;
  }

  // 3. 无解锁条件的地点
  if (!location.解锁条件) {
    return true;
  }

  // 4. TODO: 实现基于事件的解锁检查
  // 需要在事件系统中添加 "已完成事件" 列表
  // 检查 location.解锁条件 是否在已完成事件中
  return false;
}
```

#### 3.4 地图数据加载 (`utils/mapLoader.ts`)

**职责:**

- 加载 `data/地图数据.json`
- 缓存地图数据

**关键函数:**

```typescript
let cachedMapData: MapData | null = null;

export async function loadMapData(): Promise<MapData> {
  if (cachedMapData) {
    return cachedMapData;
  }

  const response = await fetch('/data/地图数据.json');
  cachedMapData = await response.json();
  return cachedMapData;
}
```

---

### 4. UI样式设计

#### 4.1 地图面板样式 (`styles/_panels.scss`)

**古地图风格:**

- 真实地形图背景 (需准备图片)
- 泛黄纸张叠加效果
- 水墨晕染边缘

**地图标记点层级:**

- 大区域标记: 较大的圆点 (直径12px),金色
- 中区域标记: 中等圆点 (直径8px),棕色
- 小地点: 不在地图上显示,仅在浮窗中列出

```scss
.map-container {
  width: 100%;
  height: 100%;
  display: grid;
  grid-template-columns: 250px 1fr;
  gap: 1rem;
  position: relative;
  background: linear-gradient(
    135deg,
    rgba(250, 240, 220, 0.95),
    rgba(245, 235, 215, 0.9)
  );
  filter: sepia(20%);
}

.map-canvas {
  position: relative;
  width: 100%;
  height: 100%;
  background-image: url('/assets/map-background.jpg'); // 真实地形图
  background-size: cover;
  background-position: center;

  // 泛黄纸张叠加
  &::before {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(
      135deg,
      rgba(250, 240, 220, 0.3),
      rgba(245, 235, 215, 0.2)
    );
    pointer-events: none;
  }

  svg {
    width: 100%;
    height: 100%;
  }
}

// 地点标记点
.location-marker {
  cursor: pointer;
  transition: all 0.3s ease;

  // 大区域标记 (较大)
  &.area-marker {
    circle {
      r: 12;
      fill: #d4af37;
      filter: drop-shadow(0 0 6px rgba(212, 175, 55, 0.6));
    }
  }

  // 中区域标记 (中等)
  &.region-marker {
    circle {
      r: 8;
      fill: #8b5a2b;
      filter: drop-shadow(0 0 4px rgba(139, 90, 43, 0.5));
    }
  }

  &.explored {
    text {
      fill: #44403c;
      font-family: var(--font-serif);
      font-size: 12px;
    }
  }

  &.unexplored {
    circle {
      fill: #a8a29e;
      opacity: 0.4;
    }
    pointer-events: none; // 未探索地点不可点击
  }

  &.current {
    animation: markerPulse 2s ease-in-out infinite;
  }

  &:hover.explored {
    circle {
      filter: drop-shadow(0 0 8px rgba(212, 175, 55, 0.8));
    }
  }
}

// 小地点浮窗
.location-popover {
  position: absolute;
  min-width: 200px;
  max-width: 300px;
  background: rgba(28, 25, 23, 0.95);
  border: 1px solid rgba(181, 137, 80, 0.4);
  border-radius: 8px;
  padding: 0.75rem;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
  z-index: 100;

  .popover-title {
    font-size: 0.9rem;
    color: #d4af37;
    margin-bottom: 0.5rem;
    border-bottom: 1px solid rgba(181, 137, 80, 0.2);
    padding-bottom: 0.5rem;
  }

  .location-item {
    padding: 0.5rem;
    margin: 0.25rem 0;
    background: rgba(255, 255, 255, 0.03);
    border: 1px solid rgba(255, 255, 255, 0.08);
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s ease;

    &:hover {
      background: rgba(181, 137, 80, 0.1);
      border-color: rgba(212, 175, 55, 0.3);
    }

    .location-name {
      color: var(--stone-200);
      font-size: 0.85rem;
    }

    .location-desc {
      color: var(--stone-400);
      font-size: 0.75rem;
      margin-top: 0.25rem;
    }

    &.locked {
      opacity: 0.5;
      cursor: not-allowed;

      &:hover {
        background: rgba(255, 255, 255, 0.03);
        border-color: rgba(255, 255, 255, 0.08);
      }
    }
  }
}

@keyframes markerPulse {
  0%, 100% {
    filter: drop-shadow(0 0 6px rgba(212, 175, 55, 0.6));
  }
  50% {
    filter: drop-shadow(0 0 12px rgba(212, 175, 55, 0.9));
  }
}
```

#### 4.2 指令队列样式 (`styles/_chat.scss`)

```scss
.command-queue-btn {
  width: 36px;
  height: 36px;
  flex-shrink: 0;
  background: linear-gradient(135deg, rgba(28, 25, 23, 0.6), rgba(41, 37, 36, 0.4));
  border: 1px solid rgba(181, 137, 80, 0.3);
  border-radius: 6px;
  cursor: pointer;
  position: relative;
  transition: all 0.3s ease;

  &:hover {
    border-color: rgba(212, 175, 55, 0.6);
    box-shadow: 0 0 12px rgba(181, 137, 80, 0.3);
  }

  // 指令数量徽章
  .command-count {
    position: absolute;
    top: -6px;
    right: -6px;
    width: 18px;
    height: 18px;
    background: #d97706;
    border-radius: 50%;
    font-size: 10px;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
  }
}

.command-queue-popover {
  position: absolute;
  bottom: calc(100% + 8px);
  right: 0;
  width: 320px;
  max-height: 400px;
  background: #1c1917;
  border: 1px solid rgba(181, 137, 80, 0.3);
  border-radius: 8px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
  padding: 1rem;
  z-index: 100;
  overflow-y: auto;

  .command-card {
    background: rgba(255, 255, 255, 0.03);
    border: 1px solid rgba(255, 255, 255, 0.08);
    border-radius: 6px;
    padding: 0.75rem;
    margin-bottom: 0.5rem;
    display: flex;
    justify-content: space-between;
    align-items: center;

    .command-text {
      flex: 1;
      color: var(--stone-300);
      font-size: 0.9rem;
    }

    .cancel-btn {
      width: 24px;
      height: 24px;
      border: none;
      background: transparent;
      color: var(--stone-600);
      cursor: pointer;

      &:hover {
        color: var(--stone-300);
      }
    }
  }
}
```

---

### 5. 地图编辑器设计

#### 5.1 独立HTML页面 (`tools/map-editor.html`)

**功能:**

1. 上传地形图背景
2. 加载现有地图数据JSON
3. 点击图片标注地点坐标
4. 选择层级 (大区域/中区域/小地点)
5. 输入名称、描述、解锁条件
6. 导出JSON文件

**核心实现:**

```html
<!DOCTYPE html>
<html>
<head>
  <title>武侠地图编辑器</title>
  <style>
    body { margin: 0; font-family: sans-serif; }
    .editor-container { display: flex; height: 100vh; }
    .toolbar { padding: 1rem; background: #f5f5f5; border-bottom: 1px solid #ddd; }
    .canvas-wrapper { flex: 1; position: relative; overflow: auto; }
    canvas { border: 1px solid #ccc; cursor: crosshair; }
    .sidebar { width: 300px; padding: 1rem; background: #fafafa; overflow-y: auto; }
  </style>
</head>
<body>
  <div class="editor-container">
    <div style="flex: 1; display: flex; flex-direction: column;">
      <div class="toolbar">
        <input type="file" id="imageUpload" accept="image/*">
        <input type="file" id="jsonUpload" accept=".json">
        <select id="levelSelect">
          <option value="area">大区域</option>
          <option value="region">中区域</option>
          <option value="location">小地点</option>
        </select>
        <button id="exportBtn">导出JSON</button>
      </div>
      <div class="canvas-wrapper">
        <canvas id="mapCanvas"></canvas>
      </div>
    </div>
    <div class="sidebar">
      <h3>地点列表</h3>
      <div id="locationList"></div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('mapCanvas');
    const ctx = canvas.getContext('2d');
    let mapData = {};
    let backgroundImage = null;

    // 上传背景图
    document.getElementById('imageUpload').addEventListener('change', (e) => {
      const file = e.target.files[0];
      const reader = new FileReader();
      reader.onload = (event) => {
        const img = new Image();
        img.onload = () => {
          canvas.width = img.width;
          canvas.height = img.height;
          backgroundImage = img;
          redraw();
        };
        img.src = event.target.result;
      };
      reader.readAsDataURL(file);
    });

    // 点击画布记录坐标
    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = Math.round(e.clientX - rect.left);
      const y = Math.round(e.clientY - rect.top);

      const name = prompt('请输入地点名称:');
      if (name) {
        const description = prompt('请输入描述:');
        const level = document.getElementById('levelSelect').value;
        addLocation(name, description, x, y, level);
        redraw();
      }
    });

    function addLocation(name, description, x, y, level) {
      // TODO: 根据level添加到mapData的正确层级
      console.log('添加地点:', { name, description, x, y, level });
    }

    function redraw() {
      if (backgroundImage) {
        ctx.drawImage(backgroundImage, 0, 0);
      }
      // TODO: 绘制所有标记点
    }

    // 导出JSON
    document.getElementById('exportBtn').addEventListener('click', () => {
      const json = JSON.stringify(mapData, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = '地图数据.json';
      a.click();
    });
  </script>
</body>
</html>
```

---

## 实施步骤

### Phase 1: 数据层 (2-3小时)

1. **扩展类型定义** - 在 `types.ts` 添加地图和指令队列类型
2. **创建示例地图数据** - `data/地图数据.json` (包含2-3个区域的示例数据)
3. **创建地图加载工具** - `utils/mapLoader.ts`
4. **创建物品管理工具** - `utils/itemManager.ts`
5. **创建地图工具函数** - `utils/mapUtils.ts` (解锁检查)
6. **创建指令队列Hook** - `hooks/useCommandQueue.ts`

### Phase 2: 地图系统 (4-5小时)

7. **准备地图背景图** - 寻找/制作东亚地形图 (保存到 `assets/map-background.jpg`)
8. **创建MapCanvas组件** - `components/MapCanvas.tsx` (SVG标记点渲染,仅显示大区域+中区域)
9. **创建LocationPopover组件** - `components/LocationPopover.tsx` (点击中区域后弹出的小地点列表浮窗)
10. **创建MapSidebar组件** - `components/MapSidebar.tsx` (三级折叠列表)
11. **重构MapPanel组件** - `components/panels/MapPanel.tsx` (集成Canvas、Popover和Sidebar)
12. **添加地图样式** - `styles/_panels.scss` (古地图风格 + 浮窗样式)

### Phase 3: 指令队列 (3-4小时)

13. **创建CommandQueueButton** - `components/CommandQueueButton.tsx`
14. **创建CommandQueuePopover** - `components/CommandQueuePopover.tsx`
15. **修改ChatInput组件** - 在发送按钮旁边集成指令队列按钮
16. **添加指令队列样式** - `styles/_chat.scss`

### Phase 4: 物品系统增强 (2-3小时)

17. **修改InventoryPanel** - 添加点击物品生成指令的逻辑
18. **集成物品数量管理** - 调用 `decreaseItemCount()` 和 `restoreItemCount()`
19. **测试物品撤销机制** - 确保取消指令时数量正确恢复

### Phase 5: 全局集成 (2-3小时)

20. **在App.tsx集成指令队列** - 将 `useCommandQueue` 提升到全局状态
21. **扩展variableReader** - 添加 `已探索地点` 字段读取
22. **测试完整流程** - 地点点击→生成指令→发送→位置更新
23. **测试物品流程** - 物品点击→扣减→生成指令→撤销→恢复

### Phase 6: 地图编辑器 (3-4小时)

24. **创建编辑器HTML** - `tools/map-editor.html`
25. **实现图片上传和坐标标注**
26. **实现JSON导入导出**
27. **添加使用说明文档** - `tools/map-editor-guide.md`

---

## 关键文件清单

### 需要创建的新文件

- `src/武侠/data/地图数据.json` - 地图数据
- `src/武侠/utils/mapLoader.ts` - 地图数据加载
- `src/武侠/utils/mapUtils.ts` - 地图工具函数
- `src/武侠/utils/itemManager.ts` - 物品管理工具
- `src/武侠/hooks/useCommandQueue.ts` - 指令队列Hook
- `src/武侠/components/MapCanvas.tsx` - 地图画布组件
- `src/武侠/components/MapSidebar.tsx` - 地图侧边栏组件
- `src/武侠/components/LocationPopover.tsx` - 小地点浮窗组件 (新增)
- `src/武侠/components/CommandQueueButton.tsx` - 指令队列按钮
- `src/武侠/components/CommandQueuePopover.tsx` - 指令队列浮窗
- `tools/map-editor.html` - 地图编辑器
- `tools/map-editor-guide.md` - 编辑器使用说明
- `src/武侠/assets/map-background.jpg` - 地图背景图 (需准备)

### 需要修改的现有文件

- `src/武侠/types.ts` - 添加地图和指令队列类型
- `src/武侠/components/panels/MapPanel.tsx` - 完全重构
- `src/武侠/components/panels/InventoryPanel.tsx` - 添加物品使用逻辑
- `src/武侠/components/ChatInput.tsx` - 集成指令队列按钮
- `src/武侠/App.tsx` - 集成指令队列全局状态
- `src/武侠/utils/variableReader.ts` - 添加已探索地点读取
- `src/武侠/styles/_panels.scss` - 添加地图样式
- `src/武侠/styles/_chat.scss` - 添加指令队列样式

---

## 技术难点与解决方案

### 1. 物品数量撤销机制

**难点:** 点击物品立即扣减,取消指令时需要恢复原数量

**方案:**

- 在 `PendingCommand.data` 中存储 `originalCount`
- 取消指令时调用 `restoreItemCount(itemName, originalCount)`
- 使用 `era:updateByObject` 更新数量

### 2. 指令队列按钮位置

**难点:** ChatInput 组件布局紧凑,需要在发送按钮旁边插入小按钮

**方案:**

- 修改 `ChatInput.tsx` 的 `.chat-input-container` 布局
- 在发送按钮前插入 `CommandQueueButton`
- 使用 `position: relative` + `position: absolute` 实现浮窗定位

### 3. 真实地形图背景

**难点:** 需要准备合适的东亚地形图,并与古地图风格融合

**方案:**

- 使用真实地形图作为 `background-image`
- 使用 `::before` 伪元素叠加泛黄纸张效果
- 使用 `filter: sepia()` 增加古旧感
- 调整透明度使地形图与古地图风格融合

### 4. 基于事件的地点解锁

**难点:** 需要在事件系统中添加"已完成事件"追踪

**方案:**

- 在 `stat_data.user数据` 中添加 `已完成事件: []` 字段
- 事件完成时,将事件ID添加到此数组
- `isLocationUnlocked()` 检查 `location.解锁条件` 是否在已完成事件中
- **注意:** 这需要在事件系统中额外开发,本次实施中先实现框架

---

## 验证测试

### 地图系统测试

1. ✅ 打开地图面板,查看地形图背景和古地图效果是否正确
2. ✅ 检查地图上仅显示大区域和中区域标记点 (无小地点标记)
3. ✅ 点击中区域标记点,检查是否弹出小地点列表浮窗
4. ✅ 在浮窗中点击小地点,检查是否生成"前往XX"指令
5. ✅ 点击未探索的中区域,检查是否无法点击
6. ✅ 发送指令后,检查 `stat_data.user数据.所在位置` 是否更新

### 指令队列测试

1. ✅ 点击地点,检查指令队列按钮是否显示数量徽章
2. ✅ 点击指令队列按钮,检查浮窗是否弹出并显示指令列表
3. ✅ 点击指令取消按钮,检查指令是否从列表移除
4. ✅ 点击发送按钮,检查所有指令是否合并发送

### 物品系统测试

1. ✅ 点击物品,检查数量是否立即减1
2. ✅ 检查是否生成"使用XX"指令
3. ✅ 取消指令,检查物品数量是否恢复
4. ✅ 物品数量为0时,检查是否自动从包裹中删除

### 地图编辑器测试

1. ✅ 上传地形图片,检查是否正确显示
2. ✅ 点击图片,检查是否记录正确的像素坐标
3. ✅ 导出JSON,检查格式是否符合预期
4. ✅ 将导出的JSON放入 `data/` 目录,检查前端是否正确加载

---

## 后续优化方向

1. **地图缩放/拖拽** - 实现地图的缩放和拖拽功能
2. **路径连线** - 在地图上绘制地点之间的路径连线
3. **事件标记** - 在地图上标记关联事件的位置
4. **动画效果** - 地点解锁时的动画效果
5. **多地图支持** - 支持切换不同的地图 (如中原地图、西域地图)
6. **完善事件解锁系统** - 在事件系统中实现"已完成事件"追踪

---

## 预计工作量

- **Phase 1 (数据层)**: 2-3小时
- **Phase 2 (地图系统)**: 4-5小时
- **Phase 3 (指令队列)**: 3-4小时
- **Phase 4 (物品系统)**: 2-3小时
- **Phase 5 (全局集成)**: 2-3小时
- **Phase 6 (地图编辑器)**: 3-4小时

**总计**: 16-22小时

---

## 风险提示

1. **地形图准备** - 需要找到合适的东亚地形图,可能需要额外时间
2. **事件解锁系统** - 需要在事件系统中额外开发,本次实施中仅实现框架
3. **性能优化** - 大量地点标记可能影响性能,需要后续优化
4. **移动端适配** - 地图编辑器仅支持桌面端,移动端需要额外适配
