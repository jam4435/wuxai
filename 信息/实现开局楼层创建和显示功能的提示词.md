# 实现开局楼层创建和显示功能的提示词

## 项目背景

这是一个基于 React + TypeScript 的游戏项目，运行在酒馆助手（Tavern Helper）环境中。项目使用酒馆助手提供的 API 与聊天系统交互。

## 功能需求

在玩家完成开局表单填写并进入游戏后，需要实现以下功能：

1. **创建开局楼层**：在玩家完成表单后，自动创建一个包含 `<maintext>` 和 `<option>` 标签的 assistant 消息楼层
2. **读取并显示 maintext**：游戏主界面（GameScreen 组件）需要自动读取最新楼层的 `<maintext>` 内容，并在主文本框中显示

## 技术栈和依赖

- **框架**：React 19.2.3 + TypeScript
- **环境**：酒馆助手（Tavern Helper）提供的 iframe 环境
- **可用 API**：
  - `createChatMessages()` - 创建聊天消息楼层
  - `getChatMessages()` - 获取聊天消息
  - `getLastMessageId()` - 获取最新消息 ID
  - `eventOn()` - 监听事件
  - `tavern_events.MESSAGE_RECEIVED` - 消息接收事件
  - `tavern_events.CHAT_CHANGED` - 聊天变更事件

## 项目结构

```
src/horr/
├── App.tsx                    # 主应用组件，管理游戏阶段
├── types.ts                   # 类型定义
├── components/
│   └── GameScreen.tsx        # 游戏主界面组件
├── utils/
│   └── gameInitializer.ts    # 游戏初始化工具（需要创建）
└── ...
```

## 实现步骤

### 步骤 1：创建开局楼层函数

在 `src/（你的项目名）/utils/gameInitializer.ts` 中创建函数：

```typescript
import { FormData } from '../types';

/**
 * 创建开局介绍楼层
 * 在玩家完成表单后调用，创建包含 <maintext> 和 <option> 的介绍楼层
 * 
 * @param formData 玩家填写的表单数据，包含游戏所需的初始信息
 * @param openingStoryGenerator 可选，用于生成开局剧情的函数。如果不提供，将使用默认模板
 * @returns 是否成功创建楼层
 */
export async function createOpeningStoryMessage(
  formData: FormData,
  openingStoryGenerator?: (formData: FormData) => { maintext: string; option: string; sum?: string }
): Promise<boolean> {
  try {
    let maintext: string;
    let option: string;
    let sum: string | undefined;

    // 如果提供了自定义生成器，使用它；否则使用默认模板
    if (openingStoryGenerator) {
      const generated = openingStoryGenerator(formData);
      maintext = generated.maintext;
      option = generated.option;
      sum = generated.sum;
    } else {
      // 默认模板：根据表单数据生成基础开局剧情
      // 注意：这里应该根据你的游戏类型和表单字段来构建
      maintext = `<maintext>
根据玩家填写的表单数据，构建开局剧情文本。
可以使用 formData 中的字段来个性化剧情内容。
例如：formData.field1, formData.field2 等。
</maintext>`;

      option = `<option>
A. 选项一
B. 选项二
C. 选项三
</option>`;

      sum = `<sum>开局总结文本</sum>`;
    }

    // 组合完整消息
    const message = sum 
      ? `${maintext}\n\n${sum}\n\n${option}`
      : `${maintext}\n\n${option}`;

    // 使用 createChatMessages 创建 assistant 消息（1层）
    await createChatMessages(
      [
        {
          role: 'assistant',
          message: message,
        },
      ],
      {
        refresh: 'none', // 不刷新显示，由游戏界面自己读取
      },
    );

    console.log('✅ 成功创建开局介绍楼层（1层）');
    return true;
  } catch (error) {
    console.error('❌ 创建开局介绍楼层失败:', error);
    return false;
  }
}
```

**关键点**：
- `maintext` 必须包含在 `<maintext>...</maintext>` 标签中
- `option` 必须包含在 `<option>...</option>` 标签中
- `sum` 是可选的，如果提供，应包含在 `<sum>...</sum>` 标签中
- 消息格式：`<maintext>...</maintext>\n\n<sum>...</sum>\n\n<option>...</option>`（如果 sum 存在）
- 可以根据游戏类型和表单字段自定义开局剧情生成逻辑

### 步骤 2：在表单完成阶段调用创建函数

在玩家完成表单并准备进入游戏时，调用创建函数。具体时机取决于你的游戏流程设计：

**方案 A：在表单提交后立即创建**

```typescript
// 在表单提交处理函数中
const handleFormSubmit = async (formData: FormData) => {
  // 创建开局楼层
  const { createOpeningStoryMessage } = await import('./utils/gameInitializer');
  await createOpeningStoryMessage(formData);
  
  // 然后进入游戏阶段
  setPhase(GamePhase.GAME);
};
```

**方案 B：在过渡阶段创建（如 ENDING 阶段）**

```typescript
// Ending Screen Component
const EndingScreen: React.FC<{ onTransition: () => void; formData: FormData }> = ({ 
  onTransition, 
  formData 
}) => {
  useEffect(() => {
    // 在切换前创建开局楼层
    const createOpening = async () => {
      const { createOpeningStoryMessage } = await import('./utils/gameInitializer');
      await createOpeningStoryMessage(formData);
    };
    createOpening();

    const timer = setTimeout(() => {
      onTransition();
    }, 3000); // 延迟后切换到游戏页面

    return () => clearTimeout(timer);
  }, [onTransition, formData]);

  // ... 渲染代码
};
```

**关键点**：
- 创建时机应该在玩家完成表单后、进入游戏主界面之前
- 确保表单数据已经完整收集
- 可以根据需要传入自定义的开局剧情生成器

### 步骤 3：在游戏主界面中读取并显示 maintext

修改游戏主界面组件（如 `GameScreen.tsx` 或类似组件）：

```typescript
// 解析 maintext 的工具函数
function parseMaintext(messageContent: string): string {
  const maintextMatch = messageContent.match(/<maintext>([\s\S]*?)<\/maintext>/i);
  if (!maintextMatch) {
    return '';
  }
  return maintextMatch[1].trim();
}

export const GameScreen: React.FC = () => {
  const [gameState, setGameState] = useState<GameState>(INITIAL_STATE);
  // ... 其他状态

  // 从最新楼层读取 maintext
  useEffect(() => {
    const loadFromChatMessages = () => {
      try {
        // 1. 先尝试获取最新的 assistant 消息
        let messages = getChatMessages(-1, { role: 'assistant' });
        let lastMessage = messages.length > 0 ? messages[messages.length - 1] : null;

        // 2. 如果没有 assistant 消息，获取最新消息（不限制 role）
        if (!lastMessage) {
          messages = getChatMessages(-1);
          lastMessage = messages.length > 0 ? messages[messages.length - 1] : null;
        }

        if (!lastMessage) {
          return;
        }

        // 3. 解析消息中的 maintext
        const messageContent = lastMessage.message || '';
        const maintext = parseMaintext(messageContent);

        if (maintext) {
          // 4. 更新游戏状态，将 maintext 添加到历史记录
          setGameState(prev => {
            // 检查是否已经添加过这条消息（避免重复）
            const existingEntry = prev.history.find(
              entry => entry.id === `maintext-${lastMessage!.message_id}`
            );
            if (existingEntry) {
              return prev;
            }

            return {
              ...prev,
              history: [
                ...prev.history, // 保留之前的记录
                {
                  id: `maintext-${lastMessage!.message_id}`,
                  sender: 'narrator',
                  text: maintext,
                  timestamp: Date.now()
                }
              ]
            };
          });
        }
      } catch (error) {
        console.error('❌ 加载聊天消息失败:', error);
      }
    };

    // 初始加载
    loadFromChatMessages();

    // 5. 监听消息变化事件，自动更新显示
    const handleMessageReceived = () => {
      setTimeout(loadFromChatMessages, 100); // 延迟一点确保消息已写入
    };

    // 监听 CHAT_CHANGED 和 MESSAGE_RECEIVED 事件
    if (typeof eventOn !== 'undefined' && typeof tavern_events !== 'undefined') {
      eventOn(tavern_events.MESSAGE_RECEIVED, handleMessageReceived);
      eventOn(tavern_events.CHAT_CHANGED, handleMessageReceived);
    }

    return () => {
      // 清理事件监听器（如果需要）
    };
  }, []);

  // ... 其他代码
};
```

## API 使用说明

### createChatMessages

```typescript
await createChatMessages(
  [
    {
      role: 'assistant', // 或 'user' 或 'system'
      message: '消息内容',
      data?: Record<string, any> // 可选，携带变量数据
    },
  ],
  {
    refresh?: 'none' | 'affected' | 'all' // 是否刷新显示
  }
);
```

### getChatMessages

```typescript
// 获取最新一条消息
const messages = getChatMessages(-1);

// 获取最新的 assistant 消息
const messages = getChatMessages(-1, { role: 'assistant' });

// 返回的消息格式
interface ChatMessage {
  message_id: number;
  role: 'system' | 'assistant' | 'user';
  message: string;
  data?: Record<string, any>;
  // ... 其他字段
}
```

### 事件监听

```typescript
// 监听消息接收事件
eventOn(tavern_events.MESSAGE_RECEIVED, (message_id: number) => {
  console.log('收到新消息:', message_id);
});

// 监听聊天变更事件
eventOn(tavern_events.CHAT_CHANGED, (chat_file_name: string) => {
  console.log('聊天文件变更:', chat_file_name);
});
```

## 关键要点

1. **消息格式**：必须严格按照 `<maintext>...</maintext>` 和 `<option>...</option>` 的格式
2. **创建时机**：在玩家完成表单后、进入游戏主界面之前创建楼层（具体时机根据游戏流程设计）
3. **读取逻辑**：优先读取最新的 assistant 消息，如果没有则读取最新消息
4. **避免重复**：使用 message_id 作为唯一标识，避免重复添加同一条消息
5. **事件监听**：监听消息变化事件，自动更新显示内容
6. **刷新策略**：创建消息时使用 `refresh: 'none'`，由游戏界面自己控制刷新
7. **自定义生成**：可以根据游戏类型和表单字段，自定义开局剧情的生成逻辑

## 自定义开局剧情生成

你可以根据游戏类型和表单字段，自定义开局剧情的生成逻辑：

```typescript
// 示例：自定义开局剧情生成器
function customOpeningStoryGenerator(formData: FormData) {
  // 根据表单数据构建个性化的开局剧情
  const maintext = `<maintext>
根据 formData 中的字段构建开局剧情。
例如：
- formData.characterName：角色名称
- formData.startingLocation：起始地点
- formData.background：背景故事
... 等等

将这些信息整合成符合游戏风格的剧情文本。
</maintext>`;

  const option = `<option>
A. 第一个选项
B. 第二个选项
C. 第三个选项
</option>`;

  const sum = `<sum>开局总结，简要描述当前状态</sum>`;

  return { maintext, option, sum };
}

// 使用时传入生成器
await createOpeningStoryMessage(formData, customOpeningStoryGenerator);
```

## 参考实现

可以参考项目中的 `src/mhjg/utils/gameInitializer.ts` 和 `src/mhjg/components/modals/StoryModal.ts` 中的实现方式，但需要根据你的游戏类型和需求进行适配。

## 测试要点

1. 完成表单后，检查是否正确创建了开局楼层
2. 进入游戏界面后，检查是否正确显示 maintext 内容
3. 当有新消息时，检查是否自动更新显示
4. 检查是否避免了重复显示同一条消息

## 注意事项

- 所有 API 函数（`createChatMessages`、`getChatMessages` 等）都是全局可用的，不需要导入
- 事件对象 `tavern_events` 也是全局可用的
- 确保在调用 API 前检查函数是否存在（使用 `typeof` 检查）
- 错误处理要完善，避免影响游戏流程

